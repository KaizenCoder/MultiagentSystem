"""
Circuit Breaker Pattern Implementation
NextGeneration Maintenance Team - Robustesse et Gestion d'Erreurs

Impl√©mentation du pattern Circuit Breaker pour:
- Protection contre les cascades de pannes
- Retry avec exponential backoff
- Gestion intelligente des √©checs
- Monitoring des √©tats du circuit
"""

from enum import Enum
import time
import asyncio
from typing import Callable, Any, Optional
import logging
from functools import wraps

class CircuitState(Enum):
    """√âtats du circuit breaker"""
    CLOSED = "closed"        # Fonctionnement normal
    OPEN = "open"           # Circuit ouvert - rejet imm√©diat
    HALF_OPEN = "half_open" # Test de r√©cup√©ration

class CircuitBreakerOpenException(Exception):
    """Exception lev√©e quand le circuit breaker est ouvert"""
    def __init__(self, message: str, retry_after: int = 60):
        super().__init__(message)
        self.retry_after = retry_after

class CircuitBreaker:
    """Circuit breaker avec retry exponential backoff"""
    
    def __init__(self, 
                 failure_threshold: int = 5,
                 timeout_seconds: int = 60,
                 retry_multiplier: float = 2.0,
                 max_retry_delay: int = 300,
                 success_threshold: int = 3):
        """
        Initialise le circuit breaker
        
        Args:
            failure_threshold: Nombre d'√©checs avant ouverture du circuit
            timeout_seconds: Dur√©e avant tentative de r√©cup√©ration
            retry_multiplier: Multiplicateur pour exponential backoff
            max_retry_delay: D√©lai maximum entre les retries
            success_threshold: Nombre de succ√®s requis pour fermer le circuit
        """
        self.failure_threshold = failure_threshold
        self.timeout_seconds = timeout_seconds
        self.retry_multiplier = retry_multiplier
        self.max_retry_delay = max_retry_delay
        self.success_threshold = success_threshold
        
        # √âtat du circuit
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.next_retry_delay = 1
        
        # M√©triques
        self.total_calls = 0
        self.total_failures = 0
        self.total_successes = 0
        self.circuit_opens = 0
        
        # Logger
        self.logger = logging.getLogger(f"{__name__}.CircuitBreaker")
    
    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """Ex√©cution avec protection circuit breaker"""
        self.total_calls += 1
        
        # V√©rification de l'√©tat du circuit
        if self.state == CircuitState.OPEN:
            if self._should_attempt_reset():
                self._transition_to_half_open()
            else:
                time_until_retry = self._time_until_retry()
                raise CircuitBreakerOpenException(
                    f"Circuit breaker ouvert - retry dans {time_until_retry}s",
                    retry_after=time_until_retry
                )
        
        try:
            # Ex√©cution de la fonction
            if asyncio.iscoroutinefunction(func):
                result = await func(*args, **kwargs)
            else:
                result = func(*args, **kwargs)
            
            # Succ√®s - gestion de l'√©tat
            self._handle_success()
            return result
            
        except Exception as e:
            # √âchec - gestion de l'√©tat
            self._handle_failure(e)
            raise
    
    def _should_attempt_reset(self) -> bool:
        """D√©termine si une tentative de reset doit √™tre effectu√©e"""
        if self.last_failure_time is None:
            return True
        
        time_since_failure = time.time() - self.last_failure_time
        return time_since_failure >= self.timeout_seconds
    
    def _transition_to_half_open(self):
        """Transition vers l'√©tat HALF_OPEN"""
        self.state = CircuitState.HALF_OPEN
        self.success_count = 0
        self.logger.info("üîÑ Circuit breaker: Transition vers HALF_OPEN - Tentative de r√©cup√©ration")
    
    def _handle_success(self):
        """Gestion d'un succ√®s"""
        self.total_successes += 1
        
        if self.state == CircuitState.HALF_OPEN:
            self.success_count += 1
            self.logger.debug(f"‚úÖ Succ√®s en HALF_OPEN: {self.success_count}/{self.success_threshold}")
            
            if self.success_count >= self.success_threshold:
                self._transition_to_closed()
        
        elif self.state == CircuitState.CLOSED:
            # Reset du compteur d'√©checs en cas de succ√®s
            if self.failure_count > 0:
                self.failure_count = max(0, self.failure_count - 1)
                self.next_retry_delay = 1  # Reset du d√©lai
    
    def _handle_failure(self, exception: Exception):
        """Gestion d'un √©chec"""
        self.total_failures += 1
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        self.logger.warning(f"‚ùå √âchec circuit breaker: {exception} (√©checs: {self.failure_count})")
        
        # Transition vers OPEN si seuil atteint
        if self.failure_count >= self.failure_threshold:
            self._transition_to_open()
        
        # Exponential backoff
        self.next_retry_delay = min(
            self.next_retry_delay * self.retry_multiplier,
            self.max_retry_delay
        )
    
    def _transition_to_closed(self):
        """Transition vers l'√©tat CLOSED (r√©cup√©ration r√©ussie)"""
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.next_retry_delay = 1
        self.logger.info("‚úÖ Circuit breaker: Transition vers CLOSED - R√©cup√©ration r√©ussie")
    
    def _transition_to_open(self):
        """Transition vers l'√©tat OPEN (circuit ouvert)"""
        self.state = CircuitState.OPEN
        self.circuit_opens += 1
        self.logger.error(f"üí• Circuit breaker: Transition vers OPEN apr√®s {self.failure_count} √©checs")
    
    def _time_until_retry(self) -> int:
        """Calcule le temps restant avant le prochain retry"""
        if self.last_failure_time is None:
            return 0
        
        elapsed = time.time() - self.last_failure_time
        remaining = max(0, self.timeout_seconds - elapsed)
        return int(remaining)
    
    def reset(self):
        """Reset manuel du circuit breaker"""
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.next_retry_delay = 1
        self.logger.info("üîÑ Circuit breaker: Reset manuel effectu√©")
    
    def get_state(self) -> dict:
        """Retourne l'√©tat actuel du circuit breaker"""
        return {
            "state": self.state.value,
            "failure_count": self.failure_count,
            "success_count": self.success_count,
            "total_calls": self.total_calls,
            "total_failures": self.total_failures,
            "total_successes": self.total_successes,
            "circuit_opens": self.circuit_opens,
            "failure_rate": (self.total_failures / self.total_calls * 100) if self.total_calls > 0 else 0,
            "next_retry_delay": self.next_retry_delay,
            "time_until_retry": self._time_until_retry() if self.state == CircuitState.OPEN else 0
        }
    
    def get_metrics(self) -> dict:
        """Retourne les m√©triques d√©taill√©es"""
        state = self.get_state()
        
        return {
            **state,
            "availability": (self.total_successes / self.total_calls * 100) if self.total_calls > 0 else 100,
            "reliability_score": max(0, 100 - (self.circuit_opens * 10)),  # P√©nalit√© par ouverture
            "last_failure_time": self.last_failure_time,
            "uptime_percentage": self._calculate_uptime(),
            "avg_failure_recovery_time": self.timeout_seconds
        }
    
    def _calculate_uptime(self) -> float:
        """Calcule le pourcentage d'uptime"""
        if self.total_calls == 0:
            return 100.0
        
        # Estimation bas√©e sur les succ√®s vs √©checs
        return (self.total_successes / self.total_calls) * 100

# D√©corateur pour circuit breaker automatique
def circuit_breaker(failure_threshold: int = 5, 
                   timeout_seconds: int = 60,
                   retry_multiplier: float = 2.0):
    """D√©corateur pour appliquer un circuit breaker √† une fonction"""
    
    def decorator(func: Callable) -> Callable:
        # Circuit breaker sp√©cifique √† cette fonction
        cb = CircuitBreaker(
            failure_threshold=failure_threshold,
            timeout_seconds=timeout_seconds,
            retry_multiplier=retry_multiplier
        )
        
        if asyncio.iscoroutinefunction(func):
            @wraps(func)
            async def async_wrapper(*args, **kwargs):
                return await cb.call(func, *args, **kwargs)
            
            # Ajout des m√©thodes de monitoring
            async_wrapper.circuit_breaker = cb
            async_wrapper.get_circuit_state = cb.get_state
            async_wrapper.get_circuit_metrics = cb.get_metrics
            async_wrapper.reset_circuit = cb.reset
            
            return async_wrapper
        else:
            @wraps(func)
            def sync_wrapper(*args, **kwargs):
                return asyncio.run(cb.call(func, *args, **kwargs))
            
            # Ajout des m√©thodes de monitoring
            sync_wrapper.circuit_breaker = cb
            sync_wrapper.get_circuit_state = cb.get_state
            sync_wrapper.get_circuit_metrics = cb.get_metrics
            sync_wrapper.reset_circuit = cb.reset
            
            return sync_wrapper
    
    return decorator

class CircuitBreakerManager:
    """Gestionnaire centralis√© des circuit breakers"""
    
    def __init__(self):
        self.circuit_breakers: dict[str, CircuitBreaker] = {}
        self.logger = logging.getLogger(f"{__name__}.CircuitBreakerManager")
    
    def get_or_create(self, name: str, **kwargs) -> CircuitBreaker:
        """R√©cup√®re ou cr√©e un circuit breaker nomm√©"""
        if name not in self.circuit_breakers:
            self.circuit_breakers[name] = CircuitBreaker(**kwargs)
            self.logger.info(f"üîß Circuit breaker cr√©√©: {name}")
        
        return self.circuit_breakers[name]
    
    def get_all_states(self) -> dict:
        """Retourne l'√©tat de tous les circuit breakers"""
        return {
            name: cb.get_state()
            for name, cb in self.circuit_breakers.items()
        }
    
    def get_all_metrics(self) -> dict:
        """Retourne les m√©triques de tous les circuit breakers"""
        return {
            name: cb.get_metrics()
            for name, cb in self.circuit_breakers.items()
        }
    
    def reset_all(self):
        """Reset tous les circuit breakers"""
        for name, cb in self.circuit_breakers.items():
            cb.reset()
            self.logger.info(f"üîÑ Circuit breaker reset√©: {name}")
    
    def get_health_summary(self) -> dict:
        """R√©sum√© de sant√© de tous les circuit breakers"""
        total_circuits = len(self.circuit_breakers)
        open_circuits = sum(1 for cb in self.circuit_breakers.values() 
                           if cb.state == CircuitState.OPEN)
        half_open_circuits = sum(1 for cb in self.circuit_breakers.values() 
                                if cb.state == CircuitState.HALF_OPEN)
        
        return {
            "total_circuits": total_circuits,
            "healthy_circuits": total_circuits - open_circuits - half_open_circuits,
            "open_circuits": open_circuits,
            "half_open_circuits": half_open_circuits,
            "overall_health": "üü¢" if open_circuits == 0 else "üü°" if open_circuits < total_circuits / 2 else "üî¥"
        }

# Instance globale
global_circuit_manager = CircuitBreakerManager()

def get_global_circuit_manager() -> CircuitBreakerManager:
    """R√©cup√®re l'instance globale du gestionnaire de circuit breakers"""
    return global_circuit_manager

# Exemple d'usage
if __name__ == "__main__":
    # Test du circuit breaker
    import random
    
    cb = CircuitBreaker(failure_threshold=3, timeout_seconds=5)
    
    async def test_function():
        """Fonction de test qui √©choue parfois"""
        if random.random() < 0.7:  # 30% de chance d'√©chec
            raise Exception("Erreur de test")
        return "Succ√®s!"
    
    async def run_test():
        """Test du circuit breaker"""
        for i in range(20):
            try:
                result = await cb.call(test_function)
                print(f"‚úÖ Appel {i+1}: {result}")
            except CircuitBreakerOpenException as e:
                print(f"üö® Appel {i+1}: Circuit ouvert - {e}")
            except Exception as e:
                print(f"‚ùå Appel {i+1}: Erreur - {e}")
            
            # √âtat du circuit
            state = cb.get_state()
            print(f"   √âtat: {state['state']} (√©checs: {state['failure_count']})")
            
            await asyncio.sleep(0.5)
        
        # M√©triques finales
        metrics = cb.get_metrics()
        print(f"\nüìä M√©triques finales:")
        print(f"   Disponibilit√©: {metrics['availability']:.1f}%")
        print(f"   Ouvertures circuit: {metrics['circuit_opens']}")
        print(f"   Score fiabilit√©: {metrics['reliability_score']}")
    
    # Ex√©cution du test
    asyncio.run(run_test()) 