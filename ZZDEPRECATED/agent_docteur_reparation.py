#!/usr/bin/env python3
"""
ü©∫ AGENT DOCTEUR - PATTERN FACTORY NEXTGENERATION
Mission: Diagnostic et r√©paration automatique des agents d√©faillants

Architecture Pattern Factory:
- H√©rite de Agent de base  
- Impl√©mente m√©thodes abstraites obligatoires
- Configuration NextGeneration int√©gr√©e
- Logging Pattern Factory standardis√©

Responsabilit√©s:
- Diagnostic automatique des agents en erreur
- R√©paration des erreurs Pattern Factory courantes
- Restauration de la conformit√©
- Sauvegarde de s√©curit√© avant modification
- Validation post-r√©paration
- Historique des interventions
"""

import asyncio
import logging
import json
import re
import shutil
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
import sys

# Import Pattern Factory (OBLIGATOIRE selon guide)
sys.path.insert(0, str(Path(__file__).parent))
try:
    from agent_factory_implementation.core.agent_factory_architecture import Agent, Task, Result
    PATTERN_FACTORY_AVAILABLE = True
except ImportError:
    try:
        from core.agent_factory_architecture import Agent, Task, Result
        PATTERN_FACTORY_AVAILABLE = True
    except ImportError as e:
        print(f"‚ö†Ô∏è Pattern Factory non disponible: {e}")
        # Fallback pour compatibilit√©
        class Agent:
            def __init__(self, agent_type: str, **config):
                self.agent_id = f"docteur_reparation_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                self.agent_type = agent_type
                self.config = config
                self.logger = logging.getLogger("AgentDocteurReparation")
                
            async def startup(self): pass
            async def shutdown(self): pass
            async def health_check(self): return {"status": "healthy"}
        
        class Task:
            def __init__(self, task_id: str, description: str, **kwargs):
                self.task_id = task_id
                self.description = description
                
        class Result:
            def __init__(self, success: bool, data: Any = None, error: str = None):
                self.success = success
                self.data = data
                self.error = error
        
        PATTERN_FACTORY_AVAILABLE = False

class AgentDocteurReparation(Agent):
    """Agent Docteur de R√©paration - Pattern Factory NextGeneration"""
    
    def __init__(self, **config):
        # Initialisation Pattern Factory
        super().__init__("docteur_reparation", **config)
        
        # Configuration sp√©cialis√©e
        self.backup_mode = config.get("backup_mode", True)
        self.auto_repair = config.get("auto_repair", True)
        self.max_repair_attempts = config.get("max_repair_attempts", 3)
        
        # Historique des r√©parations
        self.repair_history = []
        self.backup_directory = Path.cwd() / "backups_docteur"
        
        # Templates de r√©paration Pattern Factory
        self.repair_templates = self.initialiser_templates_reparation()
        
        # Configuration logging Pattern Factory (avec fallback)
        if not hasattr(self, 'logger'):
            self.logger = logging.getLogger("AgentDocteurReparation")
        
        # Assurer que les attributs existent (fallback)
        if not hasattr(self, 'agent_id'):
            self.agent_id = f"docteur_reparation_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        if not hasattr(self, 'agent_type'):
            self.agent_type = "docteur_reparation"
            
        self.logger.info(f"ü©∫ Agent Docteur R√©paration initialis√© - ID: {self.agent_id}")
        
    # Impl√©mentation m√©thodes abstraites OBLIGATOIRES
    async def startup(self):
        """D√©marrage agent docteur r√©paration"""
        self.logger.info(f"üöÄ Agent Docteur R√©paration {self.agent_id} - D√âMARRAGE")
        
        # Cr√©ation r√©pertoire backup
        if self.backup_mode:
            await self.initialiser_backup_directory()
        
        # Chargement historique r√©parations
        await self.charger_historique_reparations()
        
        self.logger.info("‚úÖ Agent Docteur R√©paration d√©marr√© avec succ√®s")
        
    async def shutdown(self):
        """Arr√™t agent docteur r√©paration"""
        self.logger.info(f"üõë Agent Docteur R√©paration {self.agent_id} - ARR√äT")
        
        # Sauvegarde historique
        await self.sauvegarder_historique_reparations()
        
        # G√©n√©ration rapport final
        await self.generer_rapport_interventions()
        
    async def health_check(self) -> Dict[str, Any]:
        """V√©rification sant√© agent docteur r√©paration"""
        return {
            "agent_id": self.agent_id,
            "agent_type": self.agent_type,
            "status": "healthy",
            "backup_mode": self.backup_mode,
            "auto_repair": self.auto_repair,
            "repairs_performed": len(self.repair_history),
            "backup_directory": str(self.backup_directory),
            "capabilities": self.get_capabilities(),
            "timestamp": datetime.now().isoformat()
        }
    
    # M√©thodes abstraites OBLIGATOIRES pour Pattern Factory
    async def execute_task(self, task: Any) -> Any:
        """Ex√©cution d'une t√¢che sp√©cifique - M√©thode abstraite obligatoire"""
        try:
            self.logger.info(f"üìã Ex√©cution t√¢che docteur: {task}")
            
            if isinstance(task, dict):
                task_type = task.get("type")
                
                if task_type == "diagnose_agent":
                    return await self.diagnostiquer_agent(task.get("agent_path"))
                elif task_type == "repair_agent":
                    return await self.reparer_agent(task.get("agent_path"))
                elif task_type == "repair_all_agents":
                    return await self.reparer_tous_agents()
                elif task_type == "restore_agent":
                    return await self.restaurer_agent(task.get("agent_path"))
            
            # T√¢che par d√©faut - diagnostic et r√©paration compl√®te
            return await self.executer_mission_complete()
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur ex√©cution t√¢che docteur: {e}")
            return {"error": str(e)}
    
    def get_capabilities(self) -> List[str]:
        """Retourne les capacit√©s de l'agent - M√©thode abstraite obligatoire"""
        return [
            "agent_diagnosis",
            "automatic_repair",
            "pattern_factory_restoration",
            "backup_management",
            "syntax_correction",
            "import_fixing",
            "method_injection",
            "compliance_restoration",
            "error_detection",
            "rollback_capability"
        ]
    
    # M√©thodes m√©tier sp√©cialis√©es
    def initialiser_templates_reparation(self) -> Dict[str, str]:
        """Initialisation des templates de r√©paration Pattern Factory"""
        return {
            "pattern_factory_import": '''# Import Pattern Factory (OBLIGATOIRE selon guide)
sys.path.insert(0, str(Path(__file__).parent))
try:
    from agent_factory_implementation.core.agent_factory_architecture import Agent, Task, Result
    PATTERN_FACTORY_AVAILABLE = True
except ImportError:
    try:
        from core.agent_factory_architecture import Agent, Task, Result
        PATTERN_FACTORY_AVAILABLE = True
    except ImportError as e:
        print(f"‚ö†Ô∏è Pattern Factory non disponible: {e}")
        # Fallback pour compatibilit√©
        class Agent:
            def __init__(self, agent_type: str, **config):
                self.agent_id = f"agent_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                self.agent_type = agent_type
                self.config = config
                self.logger = logging.getLogger(f"Agent_{agent_type}")
                
            async def startup(self): pass
            async def shutdown(self): pass
            async def health_check(self): return {"status": "healthy"}
        
        class Task:
            def __init__(self, task_id: str, description: str, **kwargs):
                self.task_id = task_id
                self.description = description
                
        class Result:
            def __init__(self, success: bool, data: Any = None, error: str = None):
                self.success = success
                self.data = data
                self.error = error
        
        PATTERN_FACTORY_AVAILABLE = False''',
            
            "required_methods": '''    # Impl√©mentation m√©thodes abstraites OBLIGATOIRES
    async def startup(self):
        """D√©marrage agent"""
        self.logger.info(f"üöÄ Agent {self.agent_id} - D√âMARRAGE")
        
    async def shutdown(self):
        """Arr√™t agent"""
        self.logger.info(f"üõë Agent {self.agent_id} - ARR√äT")
        
    async def health_check(self) -> Dict[str, Any]:
        """V√©rification sant√© agent"""
        return {
            "agent_id": self.agent_id,
            "agent_type": self.agent_type,
            "status": "healthy",
            "timestamp": datetime.now().isoformat()
        }
    
    async def execute_task(self, task: Any) -> Any:
        """Ex√©cution d'une t√¢che sp√©cifique - M√©thode abstraite obligatoire"""
        try:
            self.logger.info(f"üìã Ex√©cution t√¢che: {task}")
            # Logique m√©tier √† adapter
            return {"success": True, "result": "Task executed"}
        except Exception as e:
            self.logger.error(f"‚ùå Erreur ex√©cution t√¢che: {e}")
            return {"error": str(e)}
    
    def get_capabilities(self) -> List[str]:
        """Retourne les capacit√©s de l'agent - M√©thode abstraite obligatoire"""
        return ["basic_capability"]''',
            
            "factory_function": '''
# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_{agent_name}(**config):
    """Factory function pour cr√©er un Agent {agent_name} conforme Pattern Factory"""
    return Agent{agent_name}(**config)''',
            
            "main_function": '''
# Test de l'agent si ex√©cut√© directement
async def main():
    """Test de l'agent Pattern Factory"""
    print("üöÄ AGENT {agent_name} - PATTERN FACTORY NEXTGENERATION")
    print("=" * 50)
    
    # Cr√©er l'agent via factory
    agent = create_agent_{agent_name}()
    
    try:
        # D√©marrage Pattern Factory
        await agent.startup()
        
        # V√©rification sant√©
        health = await agent.health_check()
        print(f"üè• Health Check: {health['status']}")
        
        # Test ex√©cution
        task_test = {"type": "test"}
        result = await agent.execute_task(task_test)
        print(f"‚úÖ Test: {result}")
        
        # Arr√™t propre
        await agent.shutdown()
        
        print("\\nüéØ AGENT OP√âRATIONNEL!")
        
    except Exception as e:
        print(f"‚ùå Erreur execution agent: {e}")
        await agent.shutdown()

if __name__ == "__main__":
    asyncio.run(main())'''
        }
    
    async def initialiser_backup_directory(self):
        """Initialisation du r√©pertoire de backup"""
        try:
            self.backup_directory.mkdir(exist_ok=True)
            self.logger.info(f"‚úÖ R√©pertoire backup initialis√©: {self.backup_directory}")
        except Exception as e:
            self.logger.error(f"‚ùå Erreur cr√©ation backup directory: {e}")
            raise
    
    async def diagnostiquer_agent(self, agent_path: str) -> Dict[str, Any]:
        """Diagnostic complet d'un agent d√©faillant"""
        try:
            self.logger.info(f"üîç Diagnostic agent: {agent_path}")
            
            agent_file = Path(agent_path)
            if not agent_file.exists():
                return {"error": f"Agent non trouv√©: {agent_path}", "status": "not_found"}
            
            # Lecture du fichier
            with open(agent_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            diagnostic = {
                "agent_path": str(agent_file),
                "timestamp": datetime.now().isoformat(),
                "issues_detected": [],
                "severity": "none",
                "repair_recommendations": []
            }
            
            # Diagnostic syntaxe
            syntaxe_issues = await self.diagnostiquer_syntaxe(content, agent_file)
            if syntaxe_issues:
                diagnostic["issues_detected"].extend(syntaxe_issues)
                diagnostic["severity"] = "critical"
            
            # Diagnostic conformit√© Pattern Factory
            conformity_issues = await self.diagnostiquer_conformite_pattern_factory(content)
            if conformity_issues:
                diagnostic["issues_detected"].extend(conformity_issues)
                if diagnostic["severity"] == "none":
                    diagnostic["severity"] = "warning"
            
            # Diagnostic m√©thodes obligatoires
            methods_issues = await self.diagnostiquer_methodes_obligatoires(content)
            if methods_issues:
                diagnostic["issues_detected"].extend(methods_issues)
                diagnostic["severity"] = "critical"
            
            # G√©n√©ration recommandations
            diagnostic["repair_recommendations"] = await self.generer_recommandations_reparation(
                diagnostic["issues_detected"]
            )
            
            # Calcul priorit√© r√©paration
            diagnostic["repair_priority"] = await self.calculer_priorite_reparation(diagnostic)
            
            self.logger.info(f"‚úÖ Diagnostic termin√©: {len(diagnostic['issues_detected'])} probl√®mes d√©tect√©s")
            return diagnostic
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur diagnostic agent {agent_path}: {e}")
            return {
                "error": str(e),
                "status": "error",
                "agent_path": agent_path,
                "timestamp": datetime.now().isoformat()
            }
    
    async def diagnostiquer_syntaxe(self, content: str, agent_file: Path) -> List[Dict[str, Any]]:
        """Diagnostic des erreurs de syntaxe"""
        issues = []
        
        try:
            compile(content, str(agent_file), 'exec')
        except SyntaxError as e:
            issues.append({
                "type": "syntax_error",
                "severity": "critical",
                "line": e.lineno,
                "message": e.msg,
                "text": e.text.strip() if e.text else "",
                "repair_action": "fix_syntax"
            })
        except Exception as e:
            issues.append({
                "type": "compilation_error",
                "severity": "critical",
                "message": str(e),
                "repair_action": "manual_review"
            })
        
        return issues
    
    async def diagnostiquer_conformite_pattern_factory(self, content: str) -> List[Dict[str, Any]]:
        """Diagnostic de conformit√© Pattern Factory"""
        issues = []
        
        # V√©rification import Pattern Factory
        if ("from core.agent_factory_architecture import" not in content and 
            "from agent_factory_implementation.core" not in content):
            issues.append({
                "type": "missing_pattern_factory_import",
                "severity": "warning",
                "message": "Import Pattern Factory manquant",
                "repair_action": "add_pattern_factory_import"
            })
        
        # V√©rification h√©ritage Agent
        if not (re.search(r'class\s+\w+\s*\(\s*Agent\s*\)', content)):
            issues.append({
                "type": "missing_agent_inheritance",
                "severity": "critical",
                "message": "H√©ritage Agent manquant",
                "repair_action": "add_agent_inheritance"
            })
        
        # V√©rification fonction factory
        if not re.search(r'def\s+create_\w+.*factory', content, re.IGNORECASE):
            issues.append({
                "type": "missing_factory_function",
                "severity": "warning",
                "message": "Fonction factory manquante",
                "repair_action": "add_factory_function"
            })
        
        # V√©rification docstring Pattern Factory
        if "Pattern Factory" not in content:
            issues.append({
                "type": "missing_pattern_factory_docstring",
                "severity": "minor",
                "message": "Documentation Pattern Factory manquante",
                "repair_action": "add_pattern_factory_docstring"
            })
        
        return issues
    
    async def diagnostiquer_methodes_obligatoires(self, content: str) -> List[Dict[str, Any]]:
        """Diagnostic des m√©thodes obligatoires Pattern Factory"""
        issues = []
        
        required_methods = {
            "startup": r'async\s+def\s+startup',
            "shutdown": r'async\s+def\s+shutdown',
            "health_check": r'async\s+def\s+health_check',
            "execute_task": r'(async\s+)?def\s+execute_task',
            "get_capabilities": r'def\s+get_capabilities'
        }
        
        for method_name, pattern in required_methods.items():
            if not re.search(pattern, content):
                issues.append({
                    "type": "missing_required_method",
                    "severity": "critical",
                    "method": method_name,
                    "message": f"M√©thode obligatoire '{method_name}' manquante",
                    "repair_action": "add_required_method"
                })
        
        return issues
    
    async def generer_recommandations_reparation(self, issues: List[Dict[str, Any]]) -> List[str]:
        """G√©n√©ration des recommandations de r√©paration"""
        recommendations = []
        
        # Grouper par type d'action
        actions = {}
        for issue in issues:
            action = issue.get("repair_action", "manual_review")
            if action not in actions:
                actions[action] = []
            actions[action].append(issue)
        
        # G√©n√©rer recommandations
        for action, action_issues in actions.items():
            if action == "add_pattern_factory_import":
                recommendations.append("Ajouter l'import Pattern Factory standard")
            elif action == "add_agent_inheritance":
                recommendations.append("Corriger l'h√©ritage de la classe Agent")
            elif action == "add_required_method":
                methods = [issue["method"] for issue in action_issues if "method" in issue]
                recommendations.append(f"Ajouter m√©thodes obligatoires: {', '.join(methods)}")
            elif action == "add_factory_function":
                recommendations.append("Ajouter fonction factory de cr√©ation")
            elif action == "fix_syntax":
                recommendations.append("Corriger erreurs de syntaxe Python")
            else:
                recommendations.append(f"R√©vision manuelle requise ({action})")
        
        return recommendations
    
    async def calculer_priorite_reparation(self, diagnostic: Dict[str, Any]) -> str:
        """Calcul de la priorit√© de r√©paration"""
        severity = diagnostic.get("severity", "none")
        issues_count = len(diagnostic.get("issues_detected", []))
        
        if severity == "critical":
            return "HIGH"
        elif severity == "warning" and issues_count > 3:
            return "MEDIUM"
        elif severity == "warning":
            return "LOW"
        else:
            return "NONE"
    
    async def reparer_agent(self, agent_path: str) -> Dict[str, Any]:
        """R√©paration automatique d'un agent"""
        try:
            self.logger.info(f"üîß R√©paration agent: {agent_path}")
            
            agent_file = Path(agent_path)
            if not agent_file.exists():
                return {"error": f"Agent non trouv√©: {agent_path}", "status": "not_found"}
            
            # Diagnostic pr√©alable
            diagnostic = await self.diagnostiquer_agent(agent_path)
            if diagnostic.get("error"):
                return diagnostic
            
            # Backup de s√©curit√©
            backup_path = None
            if self.backup_mode:
                backup_path = await self.creer_backup_agent(agent_file)
            
            # Lecture contenu original
            with open(agent_file, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            repair_result = {
                "agent_path": str(agent_file),
                "timestamp": datetime.now().isoformat(),
                "backup_path": str(backup_path) if backup_path else None,
                "issues_repaired": [],
                "issues_remaining": [],
                "repair_success": False,
                "modifications_applied": []
            }
            
            # Application des r√©parations
            modified_content = original_content
            
            for issue in diagnostic.get("issues_detected", []):
                repair_action = issue.get("repair_action")
                
                if repair_action == "add_pattern_factory_import":
                    modified_content = await self.appliquer_reparation_import(modified_content)
                    repair_result["issues_repaired"].append(issue)
                    repair_result["modifications_applied"].append("Pattern Factory import ajout√©")
                
                elif repair_action == "add_required_method":
                    method_name = issue.get("method")
                    if method_name:
                        modified_content = await self.appliquer_reparation_methode(
                            modified_content, method_name
                        )
                        repair_result["issues_repaired"].append(issue)
                        repair_result["modifications_applied"].append(f"M√©thode {method_name} ajout√©e")
                
                elif repair_action == "add_factory_function":
                    agent_name = await self.extraire_nom_agent(agent_file)
                    modified_content = await self.appliquer_reparation_factory(
                        modified_content, agent_name
                    )
                    repair_result["issues_repaired"].append(issue)
                    repair_result["modifications_applied"].append("Fonction factory ajout√©e")
                
                else:
                    # R√©paration non automatique
                    repair_result["issues_remaining"].append(issue)
            
            # Sauvegarde des modifications
            if modified_content != original_content:
                with open(agent_file, 'w', encoding='utf-8') as f:
                    f.write(modified_content)
                
                repair_result["repair_success"] = True
                
                # Validation post-r√©paration
                validation = await self.valider_post_reparation(agent_file)
                repair_result["post_repair_validation"] = validation
                
                # Historique
                await self.enregistrer_reparation(repair_result)
                
                self.logger.info(f"‚úÖ R√©paration termin√©e: {len(repair_result['issues_repaired'])} corrections")
            else:
                repair_result["repair_success"] = False
                self.logger.warning("‚ö†Ô∏è Aucune modification automatique possible")
            
            return repair_result
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur r√©paration agent {agent_path}: {e}")
            return {
                "error": str(e),
                "status": "error",
                "agent_path": agent_path,
                "timestamp": datetime.now().isoformat()
            }
    
    async def creer_backup_agent(self, agent_file: Path) -> Path:
        """Cr√©ation d'un backup de s√©curit√© de l'agent"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_filename = f"{agent_file.stem}_{timestamp}.backup"
            backup_path = self.backup_directory / backup_filename
            
            shutil.copy2(agent_file, backup_path)
            
            self.logger.info(f"üíæ Backup cr√©√©: {backup_path}")
            return backup_path
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur cr√©ation backup: {e}")
            raise
    
    async def appliquer_reparation_import(self, content: str) -> str:
        """Application de la r√©paration import Pattern Factory"""
        # Recherche de la position d'insertion
        lines = content.split('\n')
        
        # Chercher apr√®s les imports standard
        insert_position = 0
        for i, line in enumerate(lines):
            if line.strip().startswith('import ') or line.strip().startswith('from '):
                insert_position = i + 1
            elif line.strip() == '' and insert_position > 0:
                break
        
        # Insertion du template
        import_template = self.repair_templates["pattern_factory_import"]
        
        # Insertion √† la bonne position
        lines.insert(insert_position, "")
        lines.insert(insert_position + 1, import_template)
        lines.insert(insert_position + 2, "")
        
        return '\n'.join(lines)
    
    async def appliquer_reparation_methode(self, content: str, method_name: str) -> str:
        """Application de la r√©paration m√©thode obligatoire"""
        method_templates = {
            "startup": '''    async def startup(self):
        """D√©marrage agent"""
        self.logger.info(f"üöÄ Agent {self.agent_id} - D√âMARRAGE")''',
            
            "shutdown": '''    async def shutdown(self):
        """Arr√™t agent"""
        self.logger.info(f"üõë Agent {self.agent_id} - ARR√äT")''',
            
            "health_check": '''    async def health_check(self) -> Dict[str, Any]:
        """V√©rification sant√© agent"""
        return {
            "agent_id": self.agent_id,
            "agent_type": self.agent_type,
            "status": "healthy",
            "timestamp": datetime.now().isoformat()
        }''',
            
            "execute_task": '''    async def execute_task(self, task: Any) -> Any:
        """Ex√©cution d'une t√¢che sp√©cifique - M√©thode abstraite obligatoire"""
        try:
            self.logger.info(f"üìã Ex√©cution t√¢che: {task}")
            # Logique m√©tier √† adapter
            return {"success": True, "result": "Task executed"}
        except Exception as e:
            self.logger.error(f"‚ùå Erreur ex√©cution t√¢che: {e}")
            return {"error": str(e)}''',
            
            "get_capabilities": '''    def get_capabilities(self) -> List[str]:
        """Retourne les capacit√©s de l'agent - M√©thode abstraite obligatoire"""
        return ["basic_capability"]'''
        }
        
        if method_name not in method_templates:
            return content
        
        # Recherche de la classe pour insertion
        lines = content.split('\n')
        class_line = -1
        
        for i, line in enumerate(lines):
            if re.match(r'class\s+\w+.*Agent.*:', line):
                class_line = i
                break
        
        if class_line == -1:
            return content
        
        # Recherche de la fin de la classe pour insertion
        insert_position = len(lines) - 1
        
        # Insertion de la m√©thode
        method_code = method_templates[method_name]
        lines.insert(insert_position, "")
        lines.insert(insert_position + 1, method_code)
        lines.insert(insert_position + 2, "")
        
        return '\n'.join(lines)
    
    async def appliquer_reparation_factory(self, content: str, agent_name: str) -> str:
        """Application de la r√©paration fonction factory"""
        factory_template = self.repair_templates["factory_function"].format(
            agent_name=agent_name
        )
        
        # Ajout √† la fin du fichier
        return content + "\n" + factory_template
    
    async def extraire_nom_agent(self, agent_file: Path) -> str:
        """Extraction du nom de l'agent depuis le fichier"""
        # Tentative d'extraction depuis le nom de fichier
        name = agent_file.stem
        if name.startswith("agent_"):
            name = name[6:]  # Enlever "agent_"
        
        # Conversion en CamelCase
        parts = name.split("_")
        return "".join(word.capitalize() for word in parts)
    
    async def valider_post_reparation(self, agent_file: Path) -> Dict[str, Any]:
        """Validation apr√®s r√©paration"""
        try:
            # V√©rification syntaxe
            with open(agent_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            try:
                compile(content, str(agent_file), 'exec')
                syntax_ok = True
            except:
                syntax_ok = False
            
            # Diagnostic rapide
            diagnostic_post = await self.diagnostiquer_agent(str(agent_file))
            
            return {
                "syntax_valid": syntax_ok,
                "remaining_issues": len(diagnostic_post.get("issues_detected", [])),
                "severity": diagnostic_post.get("severity", "none"),
                "validation_success": syntax_ok and diagnostic_post.get("severity") in ["none", "minor"]
            }
            
        except Exception as e:
            return {
                "syntax_valid": False,
                "error": str(e),
                "validation_success": False
            }
    
    async def reparer_tous_agents(self) -> Dict[str, Any]:
        """R√©paration de tous les agents d√©faillants"""
        try:
            self.logger.info("üîß R√©paration de tous les agents")
            
            workspace = Path.cwd()
            agents = list(workspace.glob("agent_*.py"))
            
            if len(agents) > 10:
                self.logger.warning(f"‚ö†Ô∏è Beaucoup d'agents ({len(agents)}), limitation √† 10 premiers")
                agents = agents[:10]
            
            resultats = {
                "timestamp": datetime.now().isoformat(),
                "total_agents": len(agents),
                "repair_results": [],
                "summary": {}
            }
            
            # R√©parations s√©quentielles pour s√©curit√©
            success_count = 0
            failed_count = 0
            
            for agent in agents:
                try:
                    # Diagnostic d'abord
                    diagnostic = await self.diagnostiquer_agent(str(agent))
                    
                    if diagnostic.get("severity") in ["critical", "warning"]:
                        # R√©paration n√©cessaire
                        repair_result = await self.reparer_agent(str(agent))
                        resultats["repair_results"].append(repair_result)
                        
                        if repair_result.get("repair_success"):
                            success_count += 1
                        else:
                            failed_count += 1
                    else:
                        # Agent sain
                        resultats["repair_results"].append({
                            "agent_path": str(agent),
                            "status": "healthy",
                            "repair_needed": False
                        })
                        
                except Exception as e:
                    failed_count += 1
                    resultats["repair_results"].append({
                        "agent_path": str(agent),
                        "error": str(e),
                        "status": "error"
                    })
            
            # Statistiques finales
            resultats["summary"] = {
                "repaired_successfully": success_count,
                "repair_failed": failed_count,
                "total_processed": len(agents),
                "success_rate": round(success_count / len(agents) * 100, 1) if agents else 0
            }
            
            self.logger.info(f"‚úÖ R√©parations termin√©es: {success_count}/{len(agents)} succ√®s")
            return resultats
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur r√©paration tous agents: {e}")
            return {"error": str(e)}
    
    async def restaurer_agent(self, agent_path: str) -> Dict[str, Any]:
        """Restauration d'un agent depuis son backup"""
        try:
            self.logger.info(f"üîÑ Restauration agent: {agent_path}")
            
            agent_file = Path(agent_path)
            
            # Recherche du backup le plus r√©cent
            agent_stem = agent_file.stem
            backups = list(self.backup_directory.glob(f"{agent_stem}_*.backup"))
            
            if not backups:
                return {
                    "error": f"Aucun backup trouv√© pour {agent_path}",
                    "status": "no_backup"
                }
            
            # Backup le plus r√©cent
            latest_backup = max(backups, key=lambda p: p.stat().st_mtime)
            
            # Restauration
            shutil.copy2(latest_backup, agent_file)
            
            result = {
                "agent_path": str(agent_file),
                "restored_from": str(latest_backup),
                "timestamp": datetime.now().isoformat(),
                "restore_success": True
            }
            
            # Validation post-restauration
            validation = await self.valider_post_reparation(agent_file)
            result["post_restore_validation"] = validation
            
            self.logger.info(f"‚úÖ Restauration termin√©e: {agent_file.name}")
            return result
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur restauration agent {agent_path}: {e}")
            return {
                "error": str(e),
                "status": "error",
                "agent_path": agent_path,
                "timestamp": datetime.now().isoformat()
            }
    
    async def executer_mission_complete(self) -> Dict[str, Any]:
        """Ex√©cution d'une mission compl√®te de diagnostic et r√©paration"""
        try:
            self.logger.info("ü©∫ Mission compl√®te diagnostic et r√©paration")
            
            resultats = {
                "timestamp": datetime.now().isoformat(),
                "mission_type": "complete",
                "phases": {}
            }
            
            # Phase 1: Diagnostic g√©n√©ral
            self.logger.info("üîç Phase 1: Diagnostic g√©n√©ral")
            resultats["phases"]["diagnostic"] = await self.diagnostiquer_tous_agents()
            
            # Phase 2: R√©parations automatiques
            self.logger.info("üîß Phase 2: R√©parations automatiques")
            resultats["phases"]["repair"] = await self.reparer_tous_agents()
            
            # Phase 3: Validation finale
            self.logger.info("‚úÖ Phase 3: Validation finale")
            resultats["phases"]["validation"] = await self.valider_tous_agents()
            
            # R√©sum√© global
            resultats["summary"] = await self.generer_resume_mission(resultats["phases"])
            
            self.logger.info("‚úÖ Mission compl√®te termin√©e")
            return resultats
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur mission compl√®te: {e}")
            return {"error": str(e)}
    
    async def diagnostiquer_tous_agents(self) -> Dict[str, Any]:
        """Diagnostic de tous les agents"""
        try:
            workspace = Path.cwd()
            agents = list(workspace.glob("agent_*.py"))
            
            diagnostics = []
            critical_count = 0
            warning_count = 0
            healthy_count = 0
            
            for agent in agents[:10]:  # Limite pour s√©curit√©
                diagnostic = await self.diagnostiquer_agent(str(agent))
                diagnostics.append(diagnostic)
                
                severity = diagnostic.get("severity", "none")
                if severity == "critical":
                    critical_count += 1
                elif severity == "warning":
                    warning_count += 1
                else:
                    healthy_count += 1
            
            return {
                "total_agents": len(diagnostics),
                "critical_issues": critical_count,
                "warning_issues": warning_count,
                "healthy_agents": healthy_count,
                "diagnostics": diagnostics
            }
            
        except Exception as e:
            return {"error": str(e)}
    
    async def valider_tous_agents(self) -> Dict[str, Any]:
        """Validation de tous les agents apr√®s r√©paration"""
        try:
            workspace = Path.cwd()
            agents = list(workspace.glob("agent_*.py"))
            
            validations = []
            valid_count = 0
            
            for agent in agents[:10]:  # Limite pour s√©curit√©
                validation = await self.valider_post_reparation(agent)
                validation["agent_path"] = str(agent)
                validations.append(validation)
                
                if validation.get("validation_success"):
                    valid_count += 1
            
            return {
                "total_validated": len(validations),
                "valid_agents": valid_count,
                "validation_rate": round(valid_count / len(validations) * 100, 1) if validations else 0,
                "validations": validations
            }
            
        except Exception as e:
            return {"error": str(e)}
    
    async def generer_resume_mission(self, phases: Dict[str, Any]) -> Dict[str, Any]:
        """G√©n√©ration du r√©sum√© de mission"""
        resume = {
            "mission_success": True,
            "issues_resolved": 0,
            "agents_improved": 0,
            "recommendations": []
        }
        
        # Analyse diagnostic
        if "diagnostic" in phases:
            diagnostic = phases["diagnostic"]
            critical = diagnostic.get("critical_issues", 0)
            warning = diagnostic.get("warning_issues", 0)
            
            if critical > 0:
                resume["recommendations"].append(f"R√©soudre {critical} probl√®mes critiques")
            if warning > 0:
                resume["recommendations"].append(f"Traiter {warning} avertissements")
        
        # Analyse r√©parations
        if "repair" in phases:
            repair = phases["repair"]
            success_rate = repair.get("summary", {}).get("success_rate", 0)
            
            if success_rate < 80:
                resume["mission_success"] = False
                resume["recommendations"].append("Taux de r√©paration insuffisant")
            
            resume["agents_improved"] = repair.get("summary", {}).get("repaired_successfully", 0)
        
        # Analyse validation
        if "validation" in phases:
            validation = phases["validation"]
            validation_rate = validation.get("validation_rate", 0)
            
            if validation_rate >= 90:
                resume["recommendations"].append("Excellent ! Agents en bonne sant√©")
            elif validation_rate >= 70:
                resume["recommendations"].append("Bon √©tat g√©n√©ral, surveillance recommand√©e")
            else:
                resume["mission_success"] = False
                resume["recommendations"].append("Attention ! Plusieurs agents n√©cessitent une intervention")
        
        return resume
    
    async def enregistrer_reparation(self, repair_result: Dict[str, Any]):
        """Enregistrement dans l'historique des r√©parations"""
        self.repair_history.append({
            "timestamp": datetime.now().isoformat(),
            "agent_path": repair_result.get("agent_path"),
            "issues_repaired": len(repair_result.get("issues_repaired", [])),
            "success": repair_result.get("repair_success", False),
            "modifications": repair_result.get("modifications_applied", [])
        })
    
    async def charger_historique_reparations(self):
        """Chargement de l'historique des r√©parations"""
        try:
            history_file = Path.cwd() / "historique_reparations_docteur.json"
            if history_file.exists():
                with open(history_file, 'r', encoding='utf-8') as f:
                    self.repair_history = json.load(f)
                self.logger.info(f"‚úÖ Historique charg√©: {len(self.repair_history)} r√©parations")
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur chargement historique: {e}")
    
    async def sauvegarder_historique_reparations(self):
        """Sauvegarde de l'historique des r√©parations"""
        try:
            history_file = Path.cwd() / "historique_reparations_docteur.json"
            with open(history_file, 'w', encoding='utf-8') as f:
                json.dump(self.repair_history, f, indent=2, ensure_ascii=False)
            self.logger.info(f"‚úÖ Historique sauvegard√©: {len(self.repair_history)} r√©parations")
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur sauvegarde historique: {e}")
    
    async def generer_rapport_interventions(self):
        """G√©n√©ration du rapport final des interventions"""
        try:
            rapport = {
                "session_info": {
                    "agent_id": self.agent_id,
                    "session_start": getattr(self, 'start_time', datetime.now().isoformat()),
                    "session_end": datetime.now().isoformat(),
                    "backup_mode": self.backup_mode,
                    "auto_repair": self.auto_repair
                },
                "statistics": {
                    "total_repairs": len(self.repair_history),
                    "successful_repairs": len([r for r in self.repair_history if r.get("success")]),
                    "agents_processed": len(set(r.get("agent_path") for r in self.repair_history if r.get("agent_path")))
                },
                "interventions": self.repair_history,
                "capabilities_used": self.get_capabilities()
            }
            
            rapport_file = Path.cwd() / f"rapport_interventions_docteur_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            with open(rapport_file, 'w', encoding='utf-8') as f:
                json.dump(rapport, f, indent=2, ensure_ascii=False)
                
            self.logger.info(f"üìÑ Rapport interventions g√©n√©r√©: {rapport_file}")
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur g√©n√©ration rapport: {e}")

# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_docteur_reparation(**config) -> AgentDocteurReparation:
    """Factory function pour cr√©er un Agent Docteur R√©paration conforme Pattern Factory"""
    return AgentDocteurReparation(**config)

# Test de l'agent si ex√©cut√© directement
async def main():
    """Test de l'agent Pattern Factory"""
    print("ü©∫ AGENT DOCTEUR R√âPARATION - PATTERN FACTORY NEXTGENERATION")
    print("=" * 70)
    
    # Cr√©er l'agent via factory
    agent = create_agent_docteur_reparation(backup_mode=True, auto_repair=True)
    
    try:
        # D√©marrage Pattern Factory
        await agent.startup()
        
        # V√©rification sant√©
        health = await agent.health_check()
        print(f"üè• Health Check: {health['status']} - Backup: {'On' if health['backup_mode'] else 'Off'}")
        
        # Mission compl√®te de diagnostic et r√©paration
        print("\nü©∫ Mission compl√®te diagnostic et r√©paration...")
        task_mission = {
            "type": "repair_all_agents"
        }
        
        results = await agent.execute_task(task_mission)
        if "summary" in results:
            summary = results["summary"]
            print(f"‚úÖ Mission termin√©e:")
            print(f"   - Agents trait√©s: {summary['total_processed']}")
            print(f"   - R√©parations r√©ussies: {summary['repaired_successfully']}")
            print(f"   - Taux de succ√®s: {summary['success_rate']}%")
        
        # Arr√™t propre
        await agent.shutdown()
        
        print("\nüéØ AGENT DOCTEUR OP√âRATIONNEL!")
        
    except Exception as e:
        print(f"‚ùå Erreur execution agent docteur: {e}")
        await agent.shutdown()

if __name__ == "__main__":
    asyncio.run(main()) 