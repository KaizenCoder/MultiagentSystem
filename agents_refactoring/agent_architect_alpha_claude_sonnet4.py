#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üèóÔ∏è AGENT ARCHITECT ALPHA - CLAUDE SONNET 4
Phase 2: Architecture Modulaire avec Principes SRP

Mission: Concevoir architecture modulaire pour les 4 fichiers god mode
- main.py (1,990 lignes ‚Üí ~100 lignes)
- advanced_coordination.py (779 lignes ‚Üí ~150 lignes) 
- redis_cluster_manager.py (738 lignes ‚Üí ~150 lignes)
- monitoring.py (709 lignes ‚Üí ~150 lignes)

Sp√©cialisation: Architecture Enterprise avec Patterns Avanc√©s
"""

import os
import json
import datetime
import asyncio
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
import anthropic
from dotenv import load_dotenv

load_dotenv()

@dataclass
class ArchitecturalPlan:
    """Plan architectural pour un fichier"""
    file_path: str
    current_lines: int
    target_lines: int
    modules_to_extract: List[Dict[str, Any]]
    dependencies: List[str]
    patterns_applied: List[str]
    migration_strategy: str
    risk_level: str
    estimated_effort_hours: int

@dataclass
class ModuleExtraction:
    """Extraction d'un module sp√©cifique"""
    name: str
    new_path: str
    responsibilities: List[str]
    interfaces: List[Dict[str, Any]]
    dependencies: List[str]
    tests_required: bool
    priority: int

class AgentArchitectAlphaClaude:
    """
    üèóÔ∏è Agent Architect Alpha - Claude Sonnet 4
    
    Expertise:
    - Single Responsibility Principle (SRP)
    - Dependency Injection Patterns
    - Clean Architecture Layers
    - Interface Segregation
    - Factory & Builder Patterns
    """
    
    def __init__(self):
        self.client = anthropic.Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))
        self.model = "claude-3-5-sonnet-20241022"
        self.workspace_path = Path(__file__).parent.parent
        self.results_path = self.workspace_path / "refactoring_workspace" / "results" / "alpha_claude"
        self.results_path.mkdir(parents=True, exist_ok=True)
        
        # Configuration architecture
        self.architectural_principles = [
            "Single Responsibility Principle",
            "Dependency Inversion Principle", 
            "Interface Segregation Principle",
            "Composition over Inheritance",
            "Fail Fast Design",
            "Immutable Data Structures",
            "Pure Functions Pattern",
            "Factory Pattern",
            "Repository Pattern",
            "Service Layer Pattern"
        ]
        
        self.patterns_library = {
            "routes": "FastAPI Router Pattern avec Dependency Injection",
            "services": "Service Layer avec Business Logic pure",
            "repositories": "Repository Pattern pour acc√®s donn√©es",
            "models": "Domain Models avec Pydantic",
            "middleware": "Middleware Chain Pattern",
            "config": "Configuration Factory Pattern",
            "errors": "Exception Hierarchy centralis√©e",
            "events": "Event-Driven Architecture",
            "cache": "Cache Abstraction Layer",
            "monitoring": "Observability Pattern"
        }

    async def analyze_god_mode_file(self, file_path: str) -> ArchitecturalPlan:
        """
        üîç Analyser un fichier god mode et cr√©er plan architectural
        """
        try:
            # Lire le fichier
            full_path = self.workspace_path / file_path
            with open(full_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Pr√©parer prompt Claude
            prompt = self._create_architecture_prompt(file_path, content)
            
            # Analyser avec Claude
            response = await self._call_claude_async(prompt)
            
            # Parser r√©ponse et cr√©er plan
            plan = self._parse_architectural_response(file_path, response)
            
            # Sauvegarder plan
            await self._save_architectural_plan(plan)
            
            return plan
            
        except Exception as e:
            print(f"‚ùå Erreur analyse {file_path}: {e}")
            return None

    def _create_architecture_prompt(self, file_path: str, content: str) -> str:
        """
        üéØ Cr√©er prompt architectural sp√©cialis√©
        """
        lines_count = len(content.split('\n'))
        
        prompt = f"""
Tu es un ARCHITECTE LOGICIEL EXPERT specialis√© dans le refactoring enterprise.

MISSION: Cr√©er plan architectural modulaire pour {file_path} ({lines_count} lignes)

OBJECTIFS:
- R√©duire drastiquement taille fichier (objectif: ~100-150 lignes max)
- Appliquer Single Responsibility Principle (SRP)
- Extraire modules sp√©cialis√©s avec interfaces claires
- Maintenir compatibilit√© backward totale

ANALYSE REQUISE:
1. RESPONSABILIT√âS identifi√©es dans le code
2. MODULES √† extraire avec leurs interfaces
3. PATTERNS architecturaux recommand√©s
4. STRAT√âGIE de migration √©tape par √©tape
5. D√âPENDANCES et ordre d'extraction
6. TESTS n√©cessaires pour chaque module

PATTERNS DISPONIBLES:
{json.dumps(self.patterns_library, indent=2)}

PRINCIPES √Ä RESPECTER:
{chr(10).join(f"- {p}" for p in self.architectural_principles)}

CONTRAINTES:
- Migration Blue-Green (z√©ro downtime)
- Tests de r√©gression automatis√©s
- Backward compatibility absolue
- Performance maintenue/am√©lior√©e

CODE √Ä ANALYSER:
```python
{content[:10000]}  # Premier tron√ßon pour analyse
```

R√âPONSE ATTENDUE (JSON):
{{
  "responsabilit√©s_identifi√©es": ["resp1", "resp2", ...],
  "modules_extraction": [
    {{
      "nom": "nom_module",
      "nouveau_chemin": "path/to/module.py",
      "responsabilit√©s": ["resp1"],
      "interfaces": [{{"name": "interface", "methods": ["method1"]}}],
      "d√©pendances": ["module1"],
      "priorit√©": 1
    }}
  ],
  "patterns_recommand√©s": ["pattern1", "pattern2"],
  "strat√©gie_migration": "description √©tapes",
  "niveau_risque": "FAIBLE|MOYEN|√âLEV√â",
  "effort_estim√©_heures": 8
}}
"""
        return prompt

    async def _call_claude_async(self, prompt: str) -> str:
        """
        ü§ñ Appel asynchrone √† Claude Sonnet 4
        """
        try:
            response = self.client.messages.create(
                model=self.model,
                max_tokens=4000,
                temperature=0.1,
                messages=[{"role": "user", "content": prompt}]
            )
            return response.content[0].text
            
        except Exception as e:
            print(f"‚ùå Erreur appel Claude: {e}")
            return ""

    def _parse_architectural_response(self, file_path: str, response: str) -> ArchitecturalPlan:
        """
        üìù Parser r√©ponse Claude en plan architectural
        """
        try:
            # Extraire JSON de la r√©ponse
            json_start = response.find('{')
            json_end = response.rfind('}') + 1
            
            if json_start != -1 and json_end != -1:
                json_content = response[json_start:json_end]
                data = json.loads(json_content)
                
                # Cr√©er objets ModuleExtraction
                modules = []
                for module_data in data.get('modules_extraction', []):
                    module = ModuleExtraction(
                        name=module_data.get('nom', ''),
                        new_path=module_data.get('nouveau_chemin', ''),
                        responsibilities=module_data.get('responsabilit√©s', []),
                        interfaces=module_data.get('interfaces', []),
                        dependencies=module_data.get('d√©pendances', []),
                        tests_required=True,
                        priority=module_data.get('priorit√©', 5)
                    )
                    modules.append(module)
                
                # Estimer lignes actuelles
                full_path = self.workspace_path / file_path
                with open(full_path, 'r', encoding='utf-8') as f:
                    current_lines = len(f.readlines())
                
                # Calculer lignes cibles
                target_lines = 100 if 'main.py' in file_path else 150
                
                return ArchitecturalPlan(
                    file_path=file_path,
                    current_lines=current_lines,
                    target_lines=target_lines,
                    modules_to_extract=[asdict(m) for m in modules],
                    dependencies=data.get('d√©pendances', []),
                    patterns_applied=data.get('patterns_recommand√©s', []),
                    migration_strategy=data.get('strat√©gie_migration', ''),
                    risk_level=data.get('niveau_risque', 'MOYEN'),
                    estimated_effort_hours=data.get('effort_estim√©_heures', 8)
                )
                
        except Exception as e:
            print(f"‚ùå Erreur parsing r√©ponse: {e}")
            
        # Fallback plan basique
        return ArchitecturalPlan(
            file_path=file_path,
            current_lines=1000,
            target_lines=150,
            modules_to_extract=[],
            dependencies=[],
            patterns_applied=[],
            migration_strategy="Analyse manuelle requise",
            risk_level="√âLEV√â",
            estimated_effort_hours=16
        )

    async def _save_architectural_plan(self, plan: ArchitecturalPlan):
        """
        üíæ Sauvegarder plan architectural
        """
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        file_name = Path(plan.file_path).stem
        
        # JSON d√©taill√©
        json_path = self.results_path / f"architectural_plan_{file_name}_{timestamp}.json"
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(asdict(plan), f, indent=2, ensure_ascii=False)
        
        # Rapport Markdown
        md_path = self.results_path / f"architectural_plan_{file_name}_{timestamp}.md"
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(self._generate_architectural_report(plan))
        
        print(f"‚úÖ Plan architectural sauvegard√©: {json_path}")

    def _generate_architectural_report(self, plan: ArchitecturalPlan) -> str:
        """
        üìã G√©n√©rer rapport architectural Markdown
        """
        return f"""# üèóÔ∏è Plan Architectural - {Path(plan.file_path).name}

## üìä Vue d'Ensemble

**Fichier:** `{plan.file_path}`  
**Lignes actuelles:** {plan.current_lines}  
**Objectif lignes:** {plan.target_lines}  
**R√©duction:** {((plan.current_lines - plan.target_lines) / plan.current_lines * 100):.1f}%  
**Effort estim√©:** {plan.estimated_effort_hours}h  
**Niveau risque:** {plan.risk_level}

## üéØ Modules √† Extraire

{self._format_modules_extraction(plan.modules_to_extract)}

## üèõÔ∏è Patterns Architecturaux

{chr(10).join(f"- {pattern}" for pattern in plan.patterns_applied)}

## üöÄ Strat√©gie de Migration

{plan.migration_strategy}

## üìã D√©pendances

{chr(10).join(f"- {dep}" for dep in plan.dependencies)}

---
*G√©n√©r√© par Agent Architect Alpha (Claude Sonnet 4)*
"""

    def _format_modules_extraction(self, modules: List[Dict[str, Any]]) -> str:
        """
        üìù Formater modules pour rapport
        """
        if not modules:
            return "Aucun module identifi√©"
        
        result = []
        for i, module in enumerate(modules, 1):
            result.append(f"""
### {i}. {module.get('name', 'Module')}

**Chemin:** `{module.get('new_path', '')}`  
**Priorit√©:** {module.get('priority', 5)}  
**Responsabilit√©s:**
{chr(10).join(f"- {resp}" for resp in module.get('responsibilities', []))}

**Interfaces:**
{chr(10).join(f"- {iface.get('name', '')}" for iface in module.get('interfaces', []))}
""")
        
        return "\n".join(result)

    async def create_complete_architecture(self) -> Dict[str, ArchitecturalPlan]:
        """
        üèóÔ∏è Cr√©er architecture compl√®te pour tous les fichiers god mode
        """
        god_mode_files = [
            "orchestrator/app/main.py",
            "orchestrator/app/agents/advanced_coordination.py", 
            "orchestrator/app/performance/redis_cluster_manager.py",
            "orchestrator/app/observability/monitoring.py"
        ]
        
        print("üèóÔ∏è D√©marrage analyse architecturale compl√®te...")
        plans = {}
        
        for file_path in god_mode_files:
            print(f"üîç Analyse {file_path}...")
            plan = await self.analyze_god_mode_file(file_path)
            if plan:
                plans[file_path] = plan
                print(f"‚úÖ Plan cr√©√© pour {file_path}")
            else:
                print(f"‚ùå √âchec analyse {file_path}")
        
        # G√©n√©rer rapport global
        await self._generate_global_report(plans)
        
        return plans

    async def _generate_global_report(self, plans: Dict[str, ArchitecturalPlan]):
        """
        üìä G√©n√©rer rapport architectural global
        """
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        
        total_current = sum(plan.current_lines for plan in plans.values())
        total_target = sum(plan.target_lines for plan in plans.values())
        total_effort = sum(plan.estimated_effort_hours for plan in plans.values())
        
        report = f"""# üèóÔ∏è Architecture Plan Global - Phase 2

## üìä R√©sum√© Ex√©cutif

**Date:** {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}  
**Fichiers analys√©s:** {len(plans)}  
**Lignes actuelles:** {total_current:,}  
**Lignes cibles:** {total_target:,}  
**R√©duction totale:** {((total_current - total_target) / total_current * 100):.1f}%  
**Effort total estim√©:** {total_effort}h

## üìÅ D√©tails par Fichier

{self._format_global_summary(plans)}

## üéØ Prochaines √âtapes

1. ‚úÖ Plans architecturaux cr√©√©s
2. üîÑ Cr√©er Agent Route Extractor
3. üîÑ Cr√©er Agent Services Creator
4. üîÑ D√©marrer extraction main.py (priorit√©)

---
*G√©n√©r√© par Agent Architect Alpha (Claude Sonnet 4)*
"""
        
        report_path = self.results_path / f"global_architecture_plan_{timestamp}.md"
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(report)
        
        print(f"üìä Rapport global sauvegard√©: {report_path}")

    def _format_global_summary(self, plans: Dict[str, ArchitecturalPlan]) -> str:
        """
        üìã Formater r√©sum√© global
        """
        result = []
        for file_path, plan in plans.items():
            reduction = ((plan.current_lines - plan.target_lines) / plan.current_lines * 100)
            result.append(f"""
### {Path(file_path).name}

**Lignes:** {plan.current_lines:,} ‚Üí {plan.target_lines:,} (-{reduction:.1f}%)  
**Effort:** {plan.estimated_effort_hours}h  
**Risque:** {plan.risk_level}  
**Modules:** {len(plan.modules_to_extract)}
""")
        
        return "\n".join(result)

# üéØ EXECUTION PRINCIPALE
async def main():
    """
    üöÄ Point d'entr√©e principal Agent Architect Alpha
    """
    print("üèóÔ∏è AGENT ARCHITECT ALPHA - CLAUDE SONNET 4")
    print("=" * 50)
    
    agent = AgentArchitectAlphaClaude()
    
    try:
        # Cr√©er architecture compl√®te
        plans = await agent.create_complete_architecture()
        
        print(f"\n‚úÖ SUCC√àS: {len(plans)} plans architecturaux cr√©√©s!")
        print("üéØ Pr√™t pour Phase 2 - Impl√©mentation")
        
        return plans
        
    except Exception as e:
        print(f"‚ùå ERREUR: {e}")
        return None

if __name__ == "__main__":
    import sys
    
    # V√©rification environnement
    if not os.getenv('ANTHROPIC_API_KEY'):
        print("‚ùå ANTHROPIC_API_KEY manquante dans .env")
        sys.exit(1)
    
    # Ex√©cution asynchrone
    result = asyncio.run(main())
    
    if result:
        print("üéâ Agent Architect Alpha termin√© avec succ√®s!")
    else:
        print("üí• √âchec Agent Architect Alpha")
        sys.exit(1) 