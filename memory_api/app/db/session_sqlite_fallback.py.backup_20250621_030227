"""
Configuration SQLite fallback pour r√©soudre le probl√®me UTF-8 PostgreSQL Windows
Solution temporaire recommand√©e par l'expert technique
"""
import os
import logging
from sqlalchemy import create_engine, text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Base pour les mod√®les SQLAlchemy
Base = declarative_base()

def get_database_engine():
    """
    Cr√©er le moteur de base de donn√©es avec fallback SQLite
    Solution temporaire pour √©viter le probl√®me UTF-8 PostgreSQL Windows
    """
    
    # Essayer PostgreSQL d'abord (si r√©solu)
    postgres_enabled = os.getenv("ENABLE_POSTGRES", "false").lower() == "true"
    
    if postgres_enabled:
        try:
            # Configuration PostgreSQL (si le probl√®me UTF-8 est r√©solu)
            postgres_host = os.getenv("POSTGRES_HOST", "localhost")
            postgres_port = os.getenv("POSTGRES_PORT", "5432")
            postgres_user = os.getenv("POSTGRES_USER", "postgres")
            postgres_password = os.getenv("POSTGRES_PASSWORD", "SecurePostgresPassword2024!")
            postgres_db = os.getenv("POSTGRES_DB", "nextgeneration_utf8")
            
            postgresql_url = f"postgresql://{postgres_user}:{postgres_password}@{postgres_host}:{postgres_port}/{postgres_db}?client_encoding=utf8"
            
            engine = create_engine(
                postgresql_url,
                pool_pre_ping=True,
                pool_recycle=3600,
                echo=False,
                connect_args={
                    "client_encoding": "utf8",
                    "application_name": "NextGeneration_MemoryAPI",
                    "options": "-c client_encoding=UTF8 -c lc_messages=C",
                    "connect_timeout": 10,
                },
            )
            
            # Test de connexion
            with engine.connect() as conn:
                result = conn.execute(text("SELECT 1"))
                result.scalar()
            
            logger.info("‚úÖ PostgreSQL connection successful")
            return engine
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è  PostgreSQL failed: {e}")
            logger.info("üîÑ Falling back to SQLite...")
    
    # Fallback SQLite (solution recommand√©e par l'expert)
    logger.info("üóÑÔ∏è  Using SQLite fallback database")
    
    # Chemin de la base SQLite
    db_path = os.getenv("SQLITE_DB_PATH", "./nextgeneration.db")
    sqlite_url = f"sqlite:///{db_path}"
    
    engine = create_engine(
        sqlite_url,
        echo=False,
        poolclass=StaticPool,
        connect_args={
            "check_same_thread": False,  # Permettre multi-threading
            "timeout": 20,
        },
    )
    
    logger.info(f"üìÅ SQLite database: {db_path}")
    return engine

# Cr√©er le moteur global
engine = get_database_engine()

# Session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    """Obtenir une session de base de donn√©es"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def test_database_connection():
    """
    Tester la connexion √† la base de donn√©es
    Version compatible SQLite/PostgreSQL
    """
    results = {
        "connection": False,
        "database_type": "unknown",
        "version": None,
        "encoding": None,
        "tests_passed": 0,
        "total_tests": 4
    }
    
    try:
        logger.info("üß™ Testing database connection...")
        
        db = SessionLocal()
        
        # Test 1: Connexion de base
        try:
            result = db.execute(text("SELECT 1 as test_value"))
            test_value = result.scalar()
            if test_value == 1:
                results["connection"] = True
                results["tests_passed"] += 1
                logger.info("‚úÖ Basic connection test passed")
        except Exception as e:
            logger.error(f"‚ùå Basic connection failed: {e}")
        
        # Test 2: D√©tection du type de base
        try:
            # D√©tecter SQLite vs PostgreSQL
            if "sqlite" in str(engine.url):
                results["database_type"] = "SQLite"
                
                # Version SQLite
                result = db.execute(text("SELECT sqlite_version()"))
                results["version"] = f"SQLite {result.scalar()}"
                results["encoding"] = "UTF-8"
                results["tests_passed"] += 1
                logger.info(f"‚úÖ Database type: {results['database_type']}")
                
            else:
                results["database_type"] = "PostgreSQL"
                
                # Version PostgreSQL (peut √©chouer avec le probl√®me UTF-8)
                try:
                    result = db.execute(text("SELECT version()"))
                    version = result.scalar()
                    results["version"] = version.split()[0:2]
                    results["tests_passed"] += 1
                    logger.info(f"‚úÖ Database type: {results['database_type']}")
                except:
                    logger.warning("‚ö†Ô∏è  PostgreSQL version check failed (UTF-8 issue)")
                    
        except Exception as e:
            logger.error(f"‚ùå Database type detection failed: {e}")
        
        # Test 3: Encodage UTF-8
        try:
            result = db.execute(text("SELECT 'Test UTF-8: √©√†√º√ß' as test_utf8"))
            utf8_test = result.scalar()
            if "√©√†√º√ß" in utf8_test:
                results["tests_passed"] += 1
                logger.info("‚úÖ UTF-8 encoding test passed")
        except Exception as e:
            logger.error(f"‚ùå UTF-8 test failed: {e}")
        
        # Test 4: Op√©rations de base
        try:
            # Test cr√©ation table temporaire
            if results["database_type"] == "SQLite":
                db.execute(text("""
                    CREATE TEMPORARY TABLE test_table (
                        id INTEGER PRIMARY KEY,
                        name TEXT
                    )
                """))
            else:
                db.execute(text("""
                    CREATE TEMPORARY TABLE test_table (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255)
                    )
                """))
            
            # Test insertion
            db.execute(text("INSERT INTO test_table (name) VALUES ('test')"))
            
            # Test lecture
            result = db.execute(text("SELECT name FROM test_table WHERE name = 'test'"))
            if result.scalar() == 'test':
                results["tests_passed"] += 1
                logger.info("‚úÖ Basic operations test passed")
                
        except Exception as e:
            logger.error(f"‚ùå Basic operations failed: {e}")
        
        db.close()
        
    except Exception as e:
        logger.error(f"‚ùå Database connection failed: {e}")
    
    # R√©sum√©
    success_rate = (results["tests_passed"] / results["total_tests"]) * 100
    logger.info(f"üìä Database tests: {results['tests_passed']}/{results['total_tests']} ({success_rate:.1f}%)")
    
    if results["connection"]:
        logger.info(f"‚úÖ Database operational: {results['database_type']}")
    else:
        logger.error("‚ùå Database connection failed")
    
    return results

def create_tables():
    """Cr√©er les tables de base de donn√©es"""
    try:
        logger.info("üèóÔ∏è  Creating database tables...")
        Base.metadata.create_all(bind=engine)
        logger.info("‚úÖ Tables created successfully")
        return True
    except Exception as e:
        logger.error(f"‚ùå Table creation failed: {e}")
        return False

if __name__ == "__main__":
    print("üöÄ SOLUTION SQLITE FALLBACK - TEST CONNEXION")
    print("=" * 50)
    print("Solution temporaire pour √©viter le probl√®me UTF-8 PostgreSQL Windows")
    print()
    
    # Test de connexion
    results = test_database_connection()
    
    print("\n" + "=" * 50)
    print("üìã R√âSULTATS:")
    print(f"   Type: {results['database_type']}")
    print(f"   Version: {results['version']}")
    print(f"   Encodage: {results['encoding']}")
    print(f"   Tests: {results['tests_passed']}/{results['total_tests']}")
    print(f"   Status: {'‚úÖ Op√©rationnel' if results['connection'] else '‚ùå √âchec'}")
    
    if results["connection"]:
        print("\nüéØ Base de donn√©es pr√™te pour TaskMaster NextGeneration !")
    else:
        print("\n‚ùå Probl√®me de connexion persistant") 