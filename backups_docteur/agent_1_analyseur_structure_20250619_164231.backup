#!/usr/bin/env python3
"""
üîç AGENT 1 - ANALYSEUR DE STRUCTURE (CLAUDE SONNET 4)
Mission: Analyser la structure des outils avec Pattern Factory NextGeneration

Architecture Pattern Factory:
- H√©rite de Agent de base  
- Impl√©mente m√©thodes abstraites obligatoires
- Configuration NextGeneration int√©gr√©e
- Logging Pattern Factory standardis√©

Responsabilit√©s:
- Scanner tous les fichiers Python dans le r√©pertoire source
- Analyser la structure AST de chaque fichier
- Identifier les types d'outils (automation, monitoring, conversion, etc.)
- Extraire les d√©pendances et m√©tadonn√©es
- Classer les outils par utilit√© potentielle
"""

import os
import ast
import json
import logging
import asyncio
from pathlib import Path
from typing import Dict, List, Any, Optional
import importlib.util
import re
from datetime import datetime
import sys

# Import Pattern Factory (OBLIGATOIRE selon guide)
sys.path.insert(0, str(Path(__file__).parent.parent))
try:
    from core.agent_factory_architecture import Agent, Task, Result
    PATTERN_FACTORY_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è Pattern Factory non disponible: {e}")
    # Fallback pour compatibilit√©
    class Agent:
        def __init__(self, agent_type: str, **config):
            self.agent_id = f"agent_1_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            self.agent_type = agent_type
            self.config = config
            self.logger = logging.getLogger(f"Agent1_AnalyseurStructure")
            
        async def startup(self): pass
        async def shutdown(self): pass
        async def health_check(self): return {"status": "healthy"}
    
    class Task:
        def __init__(self, task_id: str, description: str, **kwargs):
            self.task_id = task_id
            self.description = description
            
    class Result:
        def __init__(self, success: bool, data: Any = None, error: str = None):
            self.success = success
            self.data = data
            self.error = error
    
    PATTERN_FACTORY_AVAILABLE = False

class AgentAnalyseurStructure(Agent):
    """Agent sp√©cialis√© dans l'analyse de structure de code Python avec Claude Sonnet 4 - Pattern Factory NextGeneration"""
    
    def __init__(self, source_path: str = None, **config):
        # Initialisation Pattern Factory
        super().__init__("analyseur_structure", **config)
        
        # Configuration sp√©cifique √† l'agent
        self.source_path = Path(source_path) if source_path else Path("tools")
        self.analysis_results = {
            "tools": [],
            "categories": {},
            "dependencies": set(),
            "total_files": 0,
            "analyzable_files": 0
        }
        
        # Configuration logging Pattern Factory
        self.logger.info(f"üîç Agent 1 - Analyseur Structure initialis√© - ID: {self.agent_id}")
        
    # Impl√©mentation m√©thodes abstraites OBLIGATOIRES
    async def startup(self):
        """D√©marrage agent analyseur structure"""
        self.logger.info(f"üöÄ Agent Analyseur Structure {self.agent_id} - D√âMARRAGE")
        
        # V√©rifications de d√©marrage
        if not self.source_path.exists():
            self.logger.warning(f"‚ö†Ô∏è R√©pertoire source non trouv√©: {self.source_path}")
            # Cr√©er le r√©pertoire par d√©faut
            self.source_path.mkdir(parents=True, exist_ok=True)
            
        self.logger.info(f"‚úÖ R√©pertoire source configur√©: {self.source_path}")
        
    async def shutdown(self):
        """Arr√™t agent analyseur structure"""
        self.logger.info(f"üõë Agent Analyseur Structure {self.agent_id} - ARR√äT")
        
        # Nettoyage des ressources
        if hasattr(self, 'analysis_results'):
            # Convertir les sets en listes pour la s√©rialisation
            if 'dependencies' in self.analysis_results:
                self.analysis_results['dependencies'] = list(self.analysis_results['dependencies'])
                
    async def health_check(self) -> Dict[str, Any]:
        """V√©rification sant√© agent analyseur structure"""
        health_status = {
            "agent_id": self.agent_id,
            "agent_type": self.agent_type,
            "status": "healthy",
            "source_path_exists": self.source_path.exists() if hasattr(self, 'source_path') else False,
            "analysis_ready": True,
            "last_analysis_count": len(self.analysis_results.get("tools", [])),
            "timestamp": datetime.now().isoformat()
        }
        
        # V√©rifications sp√©cifiques
        if not self.source_path.exists():
            health_status["status"] = "warning"
            health_status["issues"] = ["R√©pertoire source inexistant"]
            
        return health_status
    
    # M√©thodes m√©tier (logique existante adapt√©e)
    async def analyze_tools_structure(self, source_path: str = None) -> Dict[str, Any]:
        """Analyse compl√®te de la structure des outils - Version Pattern Factory"""
        if source_path:
            self.source_path = Path(source_path)
            
        self.logger.info(f"üîç [SEARCH] D√©marrage analyse structure: {self.source_path}")
        
        if not self.source_path.exists():
            raise FileNotFoundError(f"R√©pertoire source introuvable: {self.source_path}")
            
        # Scanner tous les fichiers Python
        python_files = list(self.source_path.rglob("*.py"))
        self.analysis_results["total_files"] = len(python_files)
        
        self.logger.info(f"üìÅ [FOLDER] {len(python_files)} fichiers Python trouv√©s")
        
        # Analyser chaque fichier
        for py_file in python_files:
            try:
                tool_info = await self.analyze_single_file(py_file)
                if tool_info:
                    self.analysis_results["tools"].append(tool_info)
                    self.analysis_results["analyzable_files"] += 1
                    
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Erreur analyse {py_file.name}: {e}")
                
        # Cat√©goriser les outils
        await self.categorize_tools()
        
        # Finaliser l'analyse
        self.analysis_results["dependencies"] = list(self.analysis_results["dependencies"])
        
        self.logger.info(f"‚úÖ [CHECK] Analyse termin√©e: {self.analysis_results['analyzable_files']} outils analys√©s")
        return self.analysis_results
        
    async def analyze_single_file(self, file_path: Path) -> Optional[Dict[str, Any]]:
        """Analyse d√©taill√©e d'un fichier Python unique"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # Parse AST
            tree = ast.parse(content)
            
            # Extraction des informations
            tool_info = {
                "name": file_path.stem,
                "path": str(file_path.relative_to(self.source_path)),
                "size_bytes": file_path.stat().st_size,
                "lines_count": len(content.splitlines()),
                "functions": [],
                "classes": [],
                "imports": [],
                "docstring": ast.get_docstring(tree),
                "complexity_score": 0,
                "tool_type": "unknown",
                "utility_indicators": []
            }
            
            # Analyse AST d√©taill√©e
            await self.extract_ast_elements(tree, tool_info)
            
            # Classification du type d'outil
            tool_info["tool_type"] = await self.classify_tool_type(tool_info, content)
            
            # Score de complexit√©
            tool_info["complexity_score"] = await self.calculate_complexity_score(tool_info)
            
            # Indicateurs d'utilit√©
            tool_info["utility_indicators"] = await self.extract_utility_indicators(tool_info, content)
            
            return tool_info
            
        except Exception as e:
            self.logger.error(f"‚ùå [CROSS] Erreur analyse fichier {file_path}: {e}")
            return None
            
    async def extract_ast_elements(self, tree: ast.AST, tool_info: Dict[str, Any]):
        """Extraction des √©l√©ments AST (fonctions, classes, imports)"""
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                func_info = {
                    "name": node.name,
                    "args_count": len(node.args.args),
                    "is_async": isinstance(node, ast.AsyncFunctionDef),
                    "decorators": [ast.unparse(d) for d in node.decorator_list],
                    "docstring": ast.get_docstring(node)
                }
                tool_info["functions"].append(func_info)
                
            elif isinstance(node, ast.ClassDef):
                class_info = {
                    "name": node.name,
                    "methods_count": len([n for n in node.body if isinstance(n, ast.FunctionDef)]),
                    "bases": [ast.unparse(base) for base in node.bases],
                    "docstring": ast.get_docstring(node)
                }
                tool_info["classes"].append(class_info)
                
            elif isinstance(node, (ast.Import, ast.ImportFrom)):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        import_name = alias.name
                        tool_info["imports"].append(import_name)
                        self.analysis_results["dependencies"].add(import_name)
                        
                elif isinstance(node, ast.ImportFrom):
                    module = node.module or ""
                    for alias in node.names:
                        import_name = f"{module}.{alias.name}" if module else alias.name
                        tool_info["imports"].append(import_name)
                        if module:
                            self.analysis_results["dependencies"].add(module)
                            
    async def classify_tool_type(self, tool_info: Dict[str, Any], content: str) -> str:
        """Classification intelligente du type d'outil bas√©e sur l'analyse du code"""
        
        # Mots-cl√©s pour chaque cat√©gorie
        categories_keywords = {
            "automation": ["schedule", "cron", "task", "job", "workflow", "pipeline", "automation"],
            "monitoring": ["monitor", "watch", "log", "metric", "alert", "health", "status"],
            "conversion": ["convert", "transform", "parse", "format", "encode", "decode"],
            "generation": ["generate", "create", "build", "make", "produce", "template"],
            "utility": ["util", "helper", "tool", "common", "shared", "base"],
            "api": ["request", "response", "endpoint", "route", "server", "client"],
            "data": ["database", "db", "sql", "query", "data", "storage"],
            "file": ["file", "directory", "path", "folder", "io", "read", "write"],
            "network": ["http", "https", "socket", "network", "connection", "url"],
            "security": ["auth", "token", "encrypt", "decrypt", "hash", "security"]
        }
        
        # Analyse du nom de fichier
        filename_lower = tool_info["name"].lower()
        
        # Analyse du contenu (docstring + code)
        content_lower = content.lower()
        docstring_lower = (tool_info["docstring"] or "").lower()
        
        category_scores = {}
        
        for category, keywords in categories_keywords.items():
            score = 0
            
            # Score bas√© sur le nom de fichier (poids √©lev√©)
            for keyword in keywords:
                if keyword in filename_lower:
                    score += 3
                    
            # Score bas√© sur la docstring (poids moyen)
            for keyword in keywords:
                if keyword in docstring_lower:
                    score += 2
                    
            # Score bas√© sur le contenu (poids faible)
            for keyword in keywords:
                score += content_lower.count(keyword) * 0.5
                
            # Score bas√© sur les imports
            for import_name in tool_info["imports"]:
                for keyword in keywords:
                    if keyword in import_name.lower():
                        score += 1
                        
            category_scores[category] = score
            
        # Retourner la cat√©gorie avec le score le plus √©lev√©
        if category_scores:
            best_category = max(category_scores.items(), key=lambda x: x[1])
            if best_category[1] > 0:
                return best_category[0]
                
        return "utility"  # Cat√©gorie par d√©faut
        
    async def calculate_complexity_score(self, tool_info: Dict[str, Any]) -> int:
        """Calcul du score de complexit√© de l'outil"""
        score = 0
        
        # Complexit√© bas√©e sur le nombre de fonctions
        score += len(tool_info["functions"]) * 2
        
        # Complexit√© bas√©e sur le nombre de classes
        score += len(tool_info["classes"]) * 5
        
        # Complexit√© bas√©e sur les imports
        score += len(tool_info["imports"])
        
        # Complexit√© bas√©e sur la taille
        score += tool_info["lines_count"] // 10
        
        # Bonus pour les fonctions async
        async_functions = sum(1 for f in tool_info["functions"] if f["is_async"])
        score += async_functions * 3
        
        # Bonus pour les d√©corateurs
        decorated_functions = sum(1 for f in tool_info["functions"] if f["decorators"])
        score += decorated_functions * 2
        
        return score
        
    async def extract_utility_indicators(self, tool_info: Dict[str, Any], content: str) -> List[str]:
        """Extraction des indicateurs d'utilit√© de l'outil"""
        indicators = []
        
        # Indicateurs bas√©s sur la structure
        if len(tool_info["functions"]) > 5:
            indicators.append("multi_functional")
            
        if len(tool_info["classes"]) > 0:
            indicators.append("object_oriented")
            
        if any(f["is_async"] for f in tool_info["functions"]):
            indicators.append("async_capable")
            
        # Indicateurs bas√©s sur les imports
        important_libs = ["requests", "asyncio", "pathlib", "json", "yaml", "sqlite3", "pandas"]
        for lib in important_libs:
            if any(lib in imp for imp in tool_info["imports"]):
                indicators.append(f"uses_{lib}")
                
        # Indicateurs bas√©s sur le contenu
        if "if __name__ == '__main__':" in content:
            indicators.append("executable_script")
            
        if "argparse" in content or "click" in content:
            indicators.append("cli_interface")
            
        if "logging" in content:
            indicators.append("has_logging")
            
        if "config" in content.lower():
            indicators.append("configurable")
            
        # Indicateurs de qualit√©
        if tool_info["docstring"]:
            indicators.append("documented")
            
        if any(f["docstring"] for f in tool_info["functions"]):
            indicators.append("functions_documented")
            
        return indicators
        
    async def categorize_tools(self):
        """Cat√©gorisation finale des outils analys√©s"""
        categories = {}
        
        for tool in self.analysis_results["tools"]:
            tool_type = tool["tool_type"]
            if tool_type not in categories:
                categories[tool_type] = []
            categories[tool_type].append(tool["name"])
            
        self.analysis_results["categories"] = categories
        
        # Log des statistiques
        for category, tools in categories.items():
            self.logger.info(f"üìä [CHART] {category}: {len(tools)} outils")
    
    # M√©thodes sp√©cialis√©es Apex (conserv√©es)
    async def analyser_structure_apex(self, apex_tools_dir: str) -> Dict[str, Any]:
        """Analyse sp√©cialis√©e pour les outils Apex_VBA_FRAMEWORK - Version Pattern Factory"""
        self.logger.info(f"üîç [SEARCH] Analyse sp√©cialis√©e Apex_VBA_FRAMEWORK: {apex_tools_dir}")
        
        apex_path = Path(apex_tools_dir)
        if not apex_path.exists():
            raise FileNotFoundError(f"R√©pertoire Apex introuvable: {apex_tools_dir}")
        
        # Analyse des diff√©rents types d'outils dans Apex
        outils_apex = {
            "python_tools": [],
            "powershell_tools": [],
            "batch_tools": [],
            "vba_tools": [],
            "config_tools": [],
            "directories": []
        }
        
        # Scanner tous les fichiers et r√©pertoires
        for item in apex_path.rglob("*"):
            if item.is_file():
                if item.suffix == ".py":
                    # Analyser les outils Python
                    analyse = await self.analyze_single_file(item)
                    if analyse:
                        analyse["category"] = "python"
                        analyse["apex_subdir"] = item.parent.name
                        outils_apex["python_tools"].append(analyse)
                
                elif item.suffix == ".ps1":
                    # Analyser les scripts PowerShell
                    analyse = await self._analyser_fichier_powershell(item)
                    if analyse:
                        analyse["category"] = "powershell"
                        analyse["apex_subdir"] = item.parent.name
                        outils_apex["powershell_tools"].append(analyse)
                
                elif item.suffix in [".bat", ".cmd"]:
                    # Analyser les scripts batch
                    analyse = await self._analyser_fichier_batch(item)
                    if analyse:
                        analyse["category"] = "batch"
                        analyse["apex_subdir"] = item.parent.name
                        outils_apex["batch_tools"].append(analyse)
        
        # Statistiques globales
        total_tools = (len(outils_apex["python_tools"]) + 
                      len(outils_apex["powershell_tools"]) + 
                      len(outils_apex["batch_tools"]))
        
        # Classification par sous-r√©pertoire Apex
        categories_apex = {}
        for tool_type in ["python_tools", "powershell_tools", "batch_tools"]:
            for tool in outils_apex[tool_type]:
                subdir = tool.get("apex_subdir", "root")
                if subdir not in categories_apex:
                    categories_apex[subdir] = 0
                categories_apex[subdir] += 1
        
        resultats = {
            "source_directory": apex_tools_dir,
            "total_tools": total_tools,
            "tools_by_type": {
                "python": len(outils_apex["python_tools"]),
                "powershell": len(outils_apex["powershell_tools"]),
                "batch": len(outils_apex["batch_tools"])
            },
            "apex_directories": outils_apex["directories"],
            "tools_by_apex_category": categories_apex,
            "detailed_analysis": outils_apex,
            "analysis_timestamp": datetime.now().isoformat(),
            "analyzer_model": "Claude Sonnet 4 - Pattern Factory"
        }
        
        self.logger.info(f"‚úÖ [CHECK] Analyse Apex termin√©e: {total_tools} outils trouv√©s")
        return resultats
    
    async def _analyser_fichier_powershell(self, filepath: Path) -> Optional[Dict[str, Any]]:
        """Analyse un fichier PowerShell"""
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # D√©tection des fonctions PowerShell
            functions = []
            for line in content.split('\n'):
                if line.strip().startswith('function ') or line.strip().startswith('Function '):
                    func_name = line.split()[1].split('(')[0] if len(line.split()) > 1 else "unknown"
                    functions.append(func_name)
            
            return {
                "name": filepath.stem,
                "path": str(filepath),
                "size": filepath.stat().st_size,
                "functions": functions,
                "lines_count": len(content.split('\n')),
                "tool_type": "powershell_script",
                "complexity_score": len(functions) * 2 + len(content.split('\n')) // 10
            }
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur analyse PowerShell {filepath}: {e}")
            return None
    
    async def _analyser_fichier_batch(self, filepath: Path) -> Optional[Dict[str, Any]]:
        """Analyse un fichier batch"""
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # D√©tection des commandes batch importantes
            commands = []
            for line in content.split('\n'):
                line = line.strip().upper()
                if line and not line.startswith('::') and not line.startswith('REM'):
                    for cmd in ['ECHO', 'SET', 'IF', 'FOR', 'CALL', 'GOTO', 'XCOPY', 'ROBOCOPY']:
                        if line.startswith(cmd):
                            commands.append(cmd)
            
            return {
                "name": filepath.stem,
                "path": str(filepath),
                "size": filepath.stat().st_size,
                "commands": list(set(commands)),
                "lines_count": len(content.split('\n')),
                "tool_type": "batch_script",
                "complexity_score": len(set(commands)) * 3 + len(content.split('\n')) // 5
            }
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur analyse Batch {filepath}: {e}")
            return None

# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_analyseur_structure(source_path: str = None, **config) -> AgentAnalyseurStructure:
    """Factory function pour cr√©er un Agent Analyseur Structure conforme Pattern Factory"""
    return AgentAnalyseurStructure(source_path=source_path, **config)

# Test de l'agent si ex√©cut√© directement
async def main():
    """Test de l'agent Pattern Factory"""
    import sys
    
    if len(sys.argv) > 1:
        source_path = sys.argv[1]
    else:
        source_path = "tools"
        
    # Cr√©er l'agent via factory
    agent = create_agent_analyseur_structure(source_path=source_path)
    
    try:
        # D√©marrage Pattern Factory
        await agent.startup()
        
        # V√©rification sant√©
        health = await agent.health_check()
        print(f"üè• Health Check: {health}")
        
        # Ex√©cution mission
        results = await agent.analyze_tools_structure()
        print(json.dumps(results, indent=2, ensure_ascii=False))
        
        # Arr√™t propre
        await agent.shutdown()
        
    except Exception as e:
        print(f"‚ùå Erreur execution agent: {e}")
        await agent.shutdown()

if __name__ == "__main__":
    asyncio.run(main()) 

# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_1AnalyseurStructure(**config):
    """Factory function pour cr√©er un Agent 1AnalyseurStructure conforme Pattern Factory"""

    async def execute_task(self, task: Any) -> Any:
        """Ex√©cution d'une t√¢che sp√©cifique - M√©thode abstraite obligatoire"""
        try:
            self.logger.info(f"üìã Ex√©cution t√¢che: {task}")
            # Logique m√©tier √† adapter
            return {"success": True, "result": "Task executed"}
        except Exception as e:
            self.logger.error(f"‚ùå Erreur ex√©cution t√¢che: {e}")
            return {"error": str(e)}


    def get_capabilities(self) -> List[str]:
        """Retourne les capacit√©s de l'agent - M√©thode abstraite obligatoire"""
        return ["basic_capability"]

    return Agent1AnalyseurStructure(**config)

# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_1AnalyseurStructure(**config):
    """Factory function pour cr√©er un Agent 1AnalyseurStructure conforme Pattern Factory"""
    return Agent1AnalyseurStructure(**config)

# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_1AnalyseurStructure(**config):
    """Factory function pour cr√©er un Agent 1AnalyseurStructure conforme Pattern Factory"""
    return Agent1AnalyseurStructure(**config)

# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_1AnalyseurStructure(**config):
    """Factory function pour cr√©er un Agent 1AnalyseurStructure conforme Pattern Factory"""
    return Agent1AnalyseurStructure(**config)