#!/usr/bin/env python3
"""
ğŸ” AGENT 1 - ANALYSEUR DE STRUCTURE (CLAUDE SONNET 4)
Mission: Analyser la structure des outils avec Pattern Factory NextGeneration

Architecture Pattern Factory:
- HÃ©rite de Agent de base  
- ImplÃ©mente mÃ©thodes abstraites obligatoires
- Configuration NextGeneration intÃ©grÃ©e
- Logging Pattern Factory standardisÃ©

ResponsabilitÃ©s:
- Scanner tous les fichiers Python dans le rÃ©pertoire source
- Analyser la structure AST de chaque fichier
- Identifier les types d'outils (automation, monitoring, conversion, etc.)
- Extraire les dÃ©pendances et mÃ©tadonnÃ©es
- Classer les outils par utilitÃ© potentielle
"""

import os
import ast
import json
import logging
import asyncio
from pathlib import Path
from typing import Dict, List, Any, Optional
import importlib.util
import re
from datetime import datetime
import sys

# Import Pattern Factory (OBLIGATOIRE selon guide)
sys.path.insert(0, str(Path(__file__).parent.parent))
try:
    from core.agent_factory_architecture import Agent, Task, Result
    PATTERN_FACTORY_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Pattern Factory non disponible: {e}")
    # Fallback pour compatibilitÃ©
    class Agent:
        def __init__(self, agent_type: str, **config):
            self.agent_id = f"agent_1_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            self.agent_type = agent_type
            self.config = config
            self.logger = logging.getLogger(f"Agent1_AnalyseurStructure")
            
        async def startup(self): pass
        async def shutdown(self): pass
        async def health_check(self): return {"status": "healthy"}
    
    class Task:
        def __init__(self, task_id: str, description: str, **kwargs):
            self.task_id = task_id
            self.description = description
            
    class Result:
        def __init__(self, success: bool, data: Any = None, error: str = None):
            self.success = success
            self.data = data
            self.error = error
    
    PATTERN_FACTORY_AVAILABLE = False

class AgentAnalyseurStructure(Agent):
    """Agent spÃ©cialisÃ© dans l'analyse de structure de code Python avec Claude Sonnet 4 - Pattern Factory NextGeneration"""
    
    def __init__(self, source_path: str = None, **config):
        # Initialisation Pattern Factory
        super().__init__("analyseur_structure", **config)
        
        # Configuration spÃ©cifique Ã  l'agent
        self.source_path = Path(source_path) if source_path else Path("tools")
        self.analysis_results = {
            "tools": [],
            "categories": {},
            "dependencies": set(),
            "total_files": 0,
            "analyzable_files": 0
        }
        
        # Configuration logging Pattern Factory
        self.logger.info(f"ğŸ” Agent 1 - Analyseur Structure initialisÃ© - ID: {self.agent_id}")
        
    # ImplÃ©mentation mÃ©thodes abstraites OBLIGATOIRES
    async def startup(self):
        """DÃ©marrage agent analyseur structure"""
        self.logger.info(f"ğŸš€ Agent Analyseur Structure {self.agent_id} - DÃ‰MARRAGE")
        
        # VÃ©rifications de dÃ©marrage
        if not self.source_path.exists():
            self.logger.warning(f"âš ï¸ RÃ©pertoire source non trouvÃ©: {self.source_path}")
            # CrÃ©er le rÃ©pertoire par dÃ©faut
            self.source_path.mkdir(parents=True, exist_ok=True)
            
        self.logger.info(f"âœ… RÃ©pertoire source configurÃ©: {self.source_path}")
        
    async def shutdown(self):
        """ArrÃªt agent analyseur structure"""
        self.logger.info(f"ğŸ›‘ Agent Analyseur Structure {self.agent_id} - ARRÃŠT")
        
        # Nettoyage des ressources
        if hasattr(self, 'analysis_results'):
            # Convertir les sets en listes pour la sÃ©rialisation
            if 'dependencies' in self.analysis_results:
                self.analysis_results['dependencies'] = list(self.analysis_results['dependencies'])
                
    async def health_check(self) -> Dict[str, Any]:
        """VÃ©rification santÃ© agent analyseur structure"""
        health_status = {
            "agent_id": self.agent_id,
            "agent_type": self.agent_type,
            "status": "healthy",
            "source_path_exists": self.source_path.exists() if hasattr(self, 'source_path') else False,
            "analysis_ready": True,
            "last_analysis_count": len(self.analysis_results.get("tools", [])),
            "timestamp": datetime.now().isoformat()
        }
        
        # VÃ©rifications spÃ©cifiques
        if not self.source_path.exists():
            health_status["status"] = "warning"
            health_status["issues"] = ["RÃ©pertoire source inexistant"]
            
        return health_status
    
    # MÃ©thodes mÃ©tier (logique existante adaptÃ©e)
    async def analyze_tools_structure(self, source_path: str = None) -> Dict[str, Any]:
        """Analyse complÃ¨te de la structure des outils - Version Pattern Factory"""
        if source_path:
            self.source_path = Path(source_path)
            
        self.logger.info(f"ğŸ” [SEARCH] DÃ©marrage analyse structure: {self.source_path}")
        
        if not self.source_path.exists():
            raise FileNotFoundError(f"RÃ©pertoire source introuvable: {self.source_path}")
            
        # Scanner tous les fichiers Python
        python_files = list(self.source_path.rglob("*.py"))
        self.analysis_results["total_files"] = len(python_files)
        
        self.logger.info(f"ğŸ“ [FOLDER] {len(python_files)} fichiers Python trouvÃ©s")
        
        # Analyser chaque fichier
        for py_file in python_files:
            try:
                tool_info = await self.analyze_single_file(py_file)
                if tool_info:
                    self.analysis_results["tools"].append(tool_info)
                    self.analysis_results["analyzable_files"] += 1
                    
            except Exception as e:
                self.logger.warning(f"âš ï¸ Erreur analyse {py_file.name}: {e}")
                
        # CatÃ©goriser les outils
        await self.categorize_tools()
        
        # Finaliser l'analyse
        self.analysis_results["dependencies"] = list(self.analysis_results["dependencies"])
        
        self.logger.info(f"âœ… [CHECK] Analyse terminÃ©e: {self.analysis_results['analyzable_files']} outils analysÃ©s")
        return self.analysis_results
        
    async def analyze_single_file(self, file_path: Path) -> Optional[Dict[str, Any]]:
        """Analyse dÃ©taillÃ©e d'un fichier Python unique"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # Parse AST
            tree = ast.parse(content)
            
            # Extraction des informations
            tool_info = {
                "name": file_path.stem,
                "path": str(file_path.relative_to(self.source_path)),
                "size_bytes": file_path.stat().st_size,
                "lines_count": len(content.splitlines()),
                "functions": [],
                "classes": [],
                "imports": [],
                "docstring": ast.get_docstring(tree),
                "complexity_score": 0,
                "tool_type": "unknown",
                "utility_indicators": []
            }
            
            # Analyse AST dÃ©taillÃ©e
            await self.extract_ast_elements(tree, tool_info)
            
            # Classification du type d'outil
            tool_info["tool_type"] = await self.classify_tool_type(tool_info, content)
            
            # Score de complexitÃ©
            tool_info["complexity_score"] = await self.calculate_complexity_score(tool_info)
            
            # Indicateurs d'utilitÃ©
            tool_info["utility_indicators"] = await self.extract_utility_indicators(tool_info, content)
            
            return tool_info
            
        except Exception as e:
            self.logger.error(f"âŒ [CROSS] Erreur analyse fichier {file_path}: {e}")
            return None
            
    async def extract_ast_elements(self, tree: ast.AST, tool_info: Dict[str, Any]):
        """Extraction des Ã©lÃ©ments AST (fonctions, classes, imports)"""
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                func_info = {
                    "name": node.name,
                    "args_count": len(node.args.args),
                    "is_async": isinstance(node, ast.AsyncFunctionDef),
                    "decorators": [ast.unparse(d) for d in node.decorator_list],
                    "docstring": ast.get_docstring(node)
                }
                tool_info["functions"].append(func_info)
                
            elif isinstance(node, ast.ClassDef):
                class_info = {
                    "name": node.name,
                    "methods_count": len([n for n in node.body if isinstance(n, ast.FunctionDef)]),
                    "bases": [ast.unparse(base) for base in node.bases],
                    "docstring": ast.get_docstring(node)
                }
                tool_info["classes"].append(class_info)
                
            elif isinstance(node, (ast.Import, ast.ImportFrom)):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        import_name = alias.name
                        tool_info["imports"].append(import_name)
                        self.analysis_results["dependencies"].add(import_name)
                        
                elif isinstance(node, ast.ImportFrom):
                    module = node.module or ""
                    for alias in node.names:
                        import_name = f"{module}.{alias.name}" if module else alias.name
                        tool_info["imports"].append(import_name)
                        if module:
                            self.analysis_results["dependencies"].add(module)
                            
    async def classify_tool_type(self, tool_info: Dict[str, Any], content: str) -> str:
        """Classification intelligente du type d'outil basÃ©e sur l'analyse du code"""
        
        # Mots-clÃ©s pour chaque catÃ©gorie
        categories_keywords = {
            "automation": ["schedule", "cron", "task", "job", "workflow", "pipeline", "automation"],
            "monitoring": ["monitor", "watch", "log", "metric", "alert", "health", "status"],
            "conversion": ["convert", "transform", "parse", "format", "encode", "decode"],
            "generation": ["generate", "create", "build", "make", "produce", "template"],
            "utility": ["util", "helper", "tool", "common", "shared", "base"],
            "api": ["request", "response", "endpoint", "route", "server", "client"],
            "data": ["database", "db", "sql", "query", "data", "storage"],
            "file": ["file", "directory", "path", "folder", "io", "read", "write"],
            "network": ["http", "https", "socket", "network", "connection", "url"],
            "security": ["auth", "token", "encrypt", "decrypt", "hash", "security"]
        }
        
        # Analyse du nom de fichier
        filename_lower = tool_info["name"].lower()
        
        # Analyse du contenu (docstring + code)
        content_lower = content.lower()
        docstring_lower = (tool_info["docstring"] or "").lower()
        
        category_scores = {}
        
        for category, keywords in categories_keywords.items():
            score = 0
            
            # Score basÃ© sur le nom de fichier (poids Ã©levÃ©)
            for keyword in keywords:
                if keyword in filename_lower:
                    score += 3
                    
            # Score basÃ© sur la docstring (poids moyen)
            for keyword in keywords:
                if keyword in docstring_lower:
                    score += 2
                    
            # Score basÃ© sur le contenu (poids faible)
            for keyword in keywords:
                score += content_lower.count(keyword) * 0.5
                
            # Score basÃ© sur les imports
            for import_name in tool_info["imports"]:
                for keyword in keywords:
                    if keyword in import_name.lower():
                        score += 1
                        
            category_scores[category] = score
            
        # Retourner la catÃ©gorie avec le score le plus Ã©levÃ©
        if category_scores:
            best_category = max(category_scores.items(), key=lambda x: x[1])
            if best_category[1] > 0:
                return best_category[0]
                
        return "utility"  # CatÃ©gorie par dÃ©faut
        
    async def calculate_complexity_score(self, tool_info: Dict[str, Any]) -> int:
        """Calcul du score de complexitÃ© de l'outil"""
        score = 0
        
        # ComplexitÃ© basÃ©e sur le nombre de fonctions
        score += len(tool_info["functions"]) * 2
        
        # ComplexitÃ© basÃ©e sur le nombre de classes
        score += len(tool_info["classes"]) * 5
        
        # ComplexitÃ© basÃ©e sur les imports
        score += len(tool_info["imports"])
        
        # ComplexitÃ© basÃ©e sur la taille
        score += tool_info["lines_count"] // 10
        
        # Bonus pour les fonctions async
        async_functions = sum(1 for f in tool_info["functions"] if f["is_async"])
        score += async_functions * 3
        
        # Bonus pour les dÃ©corateurs
        decorated_functions = sum(1 for f in tool_info["functions"] if f["decorators"])
        score += decorated_functions * 2
        
        return score
        
    async def extract_utility_indicators(self, tool_info: Dict[str, Any], content: str) -> List[str]:
        """Extraction des indicateurs d'utilitÃ© de l'outil"""
        indicators = []
        
        # Indicateurs basÃ©s sur la structure
        if len(tool_info["functions"]) > 5:
            indicators.append("multi_functional")
            
        if len(tool_info["classes"]) > 0:
            indicators.append("object_oriented")
            
        if any(f["is_async"] for f in tool_info["functions"]):
            indicators.append("async_capable")
            
        # Indicateurs basÃ©s sur les imports
        important_libs = ["requests", "asyncio", "pathlib", "json", "yaml", "sqlite3", "pandas"]
        for lib in important_libs:
            if any(lib in imp for imp in tool_info["imports"]):
                indicators.append(f"uses_{lib}")
                
        # Indicateurs basÃ©s sur le contenu
        if "if __name__ == '__main__':" in content:
            indicators.append("executable_script")
            
        if "argparse" in content or "click" in content:
            indicators.append("cli_interface")
            
        if "logging" in content:
            indicators.append("has_logging")
            
        if "config" in content.lower():
            indicators.append("configurable")
            
        # Indicateurs de qualitÃ©
        if tool_info["docstring"]:
            indicators.append("documented")
            
        if any(f["docstring"] for f in tool_info["functions"]):
            indicators.append("functions_documented")
            
        return indicators
        
    async def categorize_tools(self):
        """CatÃ©gorisation finale des outils analysÃ©s"""
        categories = {}
        
        for tool in self.analysis_results["tools"]:
            tool_type = tool["tool_type"]
            if tool_type not in categories:
                categories[tool_type] = []
            categories[tool_type].append(tool["name"])
            
        self.analysis_results["categories"] = categories
        
        # Log des statistiques
        for category, tools in categories.items():
            self.logger.info(f"ğŸ“Š [CHART] {category}: {len(tools)} outils")
    
    # MÃ©thodes spÃ©cialisÃ©es Apex (conservÃ©es)
    async def analyser_structure_apex(self, apex_tools_dir: str) -> Dict[str, Any]:
        """Analyse spÃ©cialisÃ©e pour les outils Apex_VBA_FRAMEWORK - Version Pattern Factory"""
        self.logger.info(f"ğŸ” [SEARCH] Analyse spÃ©cialisÃ©e Apex_VBA_FRAMEWORK: {apex_tools_dir}")
        
        apex_path = Path(apex_tools_dir)
        if not apex_path.exists():
            raise FileNotFoundError(f"RÃ©pertoire Apex introuvable: {apex_tools_dir}")
        
        # Analyse des diffÃ©rents types d'outils dans Apex
        outils_apex = {
            "python_tools": [],
            "powershell_tools": [],
            "batch_tools": [],
            "vba_tools": [],
            "config_tools": [],
            "directories": []
        }
        
        # Scanner tous les fichiers et rÃ©pertoires
        for item in apex_path.rglob("*"):
            if item.is_file():
                if item.suffix == ".py":
                    # Analyser les outils Python
                    analyse = await self.analyze_single_file(item)
                    if analyse:
                        analyse["category"] = "python"
                        analyse["apex_subdir"] = item.parent.name
                        outils_apex["python_tools"].append(analyse)
                
                elif item.suffix == ".ps1":
                    # Analyser les scripts PowerShell
                    analyse = await self._analyser_fichier_powershell(item)
                    if analyse:
                        analyse["category"] = "powershell"
                        analyse["apex_subdir"] = item.parent.name
                        outils_apex["powershell_tools"].append(analyse)
                
                elif item.suffix in [".bat", ".cmd"]:
                    # Analyser les scripts batch
                    analyse = await self._analyser_fichier_batch(item)
                    if analyse:
                        analyse["category"] = "batch"
                        analyse["apex_subdir"] = item.parent.name
                        outils_apex["batch_tools"].append(analyse)
        
        # Statistiques globales
        total_tools = (len(outils_apex["python_tools"]) + 
                      len(outils_apex["powershell_tools"]) + 
                      len(outils_apex["batch_tools"]))
        
        # Classification par sous-rÃ©pertoire Apex
        categories_apex = {}
        for tool_type in ["python_tools", "powershell_tools", "batch_tools"]:
            for tool in outils_apex[tool_type]:
                subdir = tool.get("apex_subdir", "root")
                if subdir not in categories_apex:
                    categories_apex[subdir] = 0
                categories_apex[subdir] += 1
        
        resultats = {
            "source_directory": apex_tools_dir,
            "total_tools": total_tools,
            "tools_by_type": {
                "python": len(outils_apex["python_tools"]),
                "powershell": len(outils_apex["powershell_tools"]),
                "batch": len(outils_apex["batch_tools"])
            },
            "apex_directories": outils_apex["directories"],
            "tools_by_apex_category": categories_apex,
            "detailed_analysis": outils_apex,
            "analysis_timestamp": datetime.now().isoformat(),
            "analyzer_model": "Claude Sonnet 4 - Pattern Factory"
        }
        
        self.logger.info(f"âœ… [CHECK] Analyse Apex terminÃ©e: {total_tools} outils trouvÃ©s")
        return resultats
    
    async def _analyser_fichier_powershell(self, filepath: Path) -> Optional[Dict[str, Any]]:
        """Analyse un fichier PowerShell"""
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # DÃ©tection des fonctions PowerShell
            functions = []
            for line in content.split('\n'):
                if line.strip().startswith('function ') or line.strip().startswith('Function '):
                    func_name = line.split()[1].split('(')[0] if len(line.split()) > 1 else "unknown"
                    functions.append(func_name)
            
            return {
                "name": filepath.stem,
                "path": str(filepath),
                "size": filepath.stat().st_size,
                "functions": functions,
                "lines_count": len(content.split('\n')),
                "tool_type": "powershell_script",
                "complexity_score": len(functions) * 2 + len(content.split('\n')) // 10
            }
        except Exception as e:
            self.logger.warning(f"âš ï¸ Erreur analyse PowerShell {filepath}: {e}")
            return None
    
    async def _analyser_fichier_batch(self, filepath: Path) -> Optional[Dict[str, Any]]:
        """Analyse un fichier batch"""
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # DÃ©tection des commandes batch importantes
            commands = []
            for line in content.split('\n'):
                line = line.strip().upper()
                if line and not line.startswith('::') and not line.startswith('REM'):
                    for cmd in ['ECHO', 'SET', 'IF', 'FOR', 'CALL', 'GOTO', 'XCOPY', 'ROBOCOPY']:
                        if line.startswith(cmd):
                            commands.append(cmd)
            
            return {
                "name": filepath.stem,
                "path": str(filepath),
                "size": filepath.stat().st_size,
                "commands": list(set(commands)),
                "lines_count": len(content.split('\n')),
                "tool_type": "batch_script",
                "complexity_score": len(set(commands)) * 3 + len(content.split('\n')) // 5
            }
        except Exception as e:
            self.logger.warning(f"âš ï¸ Erreur analyse Batch {filepath}: {e}")
            return None

# Fonction factory pour crÃ©er l'agent (Pattern Factory)
def create_agent_analyseur_structure(source_path: str = None, **config) -> AgentAnalyseurStructure:
    """Factory function pour crÃ©er un Agent Analyseur Structure conforme Pattern Factory"""
    return AgentAnalyseurStructure(source_path=source_path, **config)

# Test de l'agent si exÃ©cutÃ© directement
async def main():
    """Test de l'agent Pattern Factory"""
    import sys
    
    if len(sys.argv) > 1:
        source_path = sys.argv[1]
    else:
        source_path = "tools"
        
    # CrÃ©er l'agent via factory
    agent = create_agent_analyseur_structure(source_path=source_path)
    
    try:
        # DÃ©marrage Pattern Factory
        await agent.startup()
        
        # VÃ©rification santÃ©
        health = await agent.health_check()
        print(f"ğŸ¥ Health Check: {health}")
        
        # ExÃ©cution mission
        results = await agent.analyze_tools_structure()
        print(json.dumps(results, indent=2, ensure_ascii=False))
        
        # ArrÃªt propre
        await agent.shutdown()
        
    except Exception as e:
        print(f"âŒ Erreur execution agent: {e}")
        await agent.shutdown()

if __name__ == "__main__":
    asyncio.run(main()) 