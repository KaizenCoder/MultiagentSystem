oici le troisiÃ¨me livrable contenant tous les Ã©lÃ©ments dâ€™exÃ©cution et de dÃ©ploiement local du systÃ¨me TaskMaster supervisÃ© :

ğŸ“¦ Fichier ZIP : 20250620_225933_003_docker_sqlite_make_taskmaster.zip

Contenu :
Fichier	RÃ´le
Makefile	Commandes : make start, make spawn, make test
Dockerfile	Conteneur minimal FastAPI avec supervisor intÃ©grÃ©
docker-compose.yaml	Exposition REST locale sur localhost:8001
taskmaster_registry.db	Base SQLite vide (future persistance de sessions)

Souhaitez-vous que je :

gÃ©nÃ¨re le code Python dâ€™intÃ©gration avec SQLite pour rendre le registre TaskMasterRegistry persistant ?

connecte taskmaster_pool_supervisor.py directement Ã  cette base SQLite ?

Cela permettrait de rebooter le systÃ¨me sans perte dâ€™agents enregistrÃ©s. 







Vous avez ditÂ :
oui pour les 2


ChatGPT a ditÂ :
Taskmaster Pool Supervisor

25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
# taskmaster_pool_supervisor.py
        conn.execute("""
            CREATE TABLE IF NOT EXISTS taskmasters (
                agent_id TEXT PRIMARY KEY,
                mission TEXT
            )
        """)

init_db()

# --- Registre persistant SQLite ---
class TaskMasterRegistry:
    instances: Dict[str, AgentTaskMasterNextGeneration] = {}

    @classmethod
    def register(cls, agent_id: str, instance: AgentTaskMasterNextGeneration, mission: str):
        cls.instances[agent_id] = instance
        with sqlite3.connect(DB_PATH) as conn:
            conn.execute("INSERT OR REPLACE INTO taskmasters (agent_id, mission) VALUES (?, ?)", (agent_id, mission))
        logger.info(f"TaskMaster instance registered: {agent_id}")

    @classmethod
    def get(cls, agent_id: str) -> Optional[AgentTaskMasterNextGeneration]:
        return cls.instances.get(agent_id)

    @classmethod
    def list_instances(cls):
        return list(cls.instances.keys())

    @classmethod
    def remove(cls, agent_id: str):
        if agent_id in cls.instances:
            del cls.instances[agent_id]
        with sqlite3.connect(DB_PATH) as conn:
            conn.execute("DELETE FROM taskmasters WHERE agent_id = ?", (agent_id,))
        logger.info(f"TaskMaster instance removed: {agent_id}")

    @classmethod
    def load_from_db(cls):
        with sqlite3.connect(DB_PATH) as conn:
            for agent_id, mission in conn.execute("SELECT agent_id, mission FROM taskmasters"):
                instance = AgentTaskMasterNextGeneration(agent_id=agent_id)
                cls.instances[agent_id] = instance
                asyncio.create_task(instance.create_task_from_natural_language(mission))
                logger.info(f"Restored TaskMaster: {agent_id}")

# --- API REST supervisÃ©e ---
app = FastAPI(title="TaskMaster Supervisor API")

class LaunchRequest(BaseModel):
    mission: str
    agent_id: Optional[str] = None

@app.on_event("startup")
async def restore_instances():
    TaskMasterRegistry.load_from_db()

@app.post("/launch")
async def launch_taskmaster(req: LaunchRequest):
    agent_id = req.agent_id or f"tm_{uuid4().hex[:6]}"
    instance = AgentTaskMasterNextGeneration(agent_id=agent_id)
    TaskMasterRegistry.register(agent_id, instance, req.mission)
    asyncio.create_task(instance.create_task_from_natural_language(req.mission))
    return {"status": "launched", "agent_id": agent_id}

@app.get("/instances")
Modification

RÃ©pondre plutÃ´t dans le chat
âœ… Le fichier taskmaster_pool_supervisor.py a Ã©tÃ© modifiÃ© pour intÃ©grer une base SQLite persistante et restaurer automatiquement les agents TaskMaster au redÃ©marrage.

ğŸ”§ Modifications clÃ©s apportÃ©es :
Connexion SQLite intÃ©grÃ©e (taskmaster_registry.db)

Table taskmasters(agent_id, mission) crÃ©Ã©e automatiquement

MÃ©thode register() â†’ enregistre dans la base

MÃ©thode load_from_db() â†’ restaure tous les agents avec leurs missions

Startup FastAPI â†’ relance les instances au reboot

Suppression synchronisÃ©e entre RAM et SQLite

ğŸš€ Comportement attendu :
Vous pouvez killer le serveur et relancer : les agents prÃ©cÃ©demment lancÃ©s seront automatiquement restaurÃ©s.

Lâ€™Ã©tat des missions est persistÃ© localement, 100% offline.

Souhaitez-vous maintenant :

Un outil de purge manuelle (reset_registry.py) ?

Un export JSON des agents actifs depuis la DB (dump_registry.py) ?

Lâ€™intÃ©gration de healthcheck par agent dans /instances/{agent_id} ?









Outils


