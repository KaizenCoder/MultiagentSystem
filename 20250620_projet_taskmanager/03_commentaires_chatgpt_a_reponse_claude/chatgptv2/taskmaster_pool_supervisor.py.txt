# taskmaster_pool_supervisor.py
"""
TaskMasterSupervisor - Gestionnaire d'instances TaskMaster parallèles pour NextGeneration
Version avec persistance SQLite intégrée
"""

import asyncio
import logging
import sqlite3
from uuid import uuid4
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Optional

from template_manager_integrated import AgentTaskMasterNextGeneration

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("supervisor")

DB_PATH = "taskmaster_registry.db"

# --- Gestion SQLite ---
def init_db():
    with sqlite3.connect(DB_PATH) as conn:
        conn.execute("""
            CREATE TABLE IF NOT EXISTS taskmasters (
                agent_id TEXT PRIMARY KEY,
                mission TEXT
            )
        """)

init_db()

# --- Registre persistant SQLite ---
class TaskMasterRegistry:
    instances: Dict[str, AgentTaskMasterNextGeneration] = {}

    @classmethod
    def register(cls, agent_id: str, instance: AgentTaskMasterNextGeneration, mission: str):
        cls.instances[agent_id] = instance
        with sqlite3.connect(DB_PATH) as conn:
            conn.execute("INSERT OR REPLACE INTO taskmasters (agent_id, mission) VALUES (?, ?)", (agent_id, mission))
        logger.info(f"TaskMaster instance registered: {agent_id}")

    @classmethod
    def get(cls, agent_id: str) -> Optional[AgentTaskMasterNextGeneration]:
        return cls.instances.get(agent_id)

    @classmethod
    def list_instances(cls):
        return list(cls.instances.keys())

    @classmethod
    def remove(cls, agent_id: str):
        if agent_id in cls.instances:
            del cls.instances[agent_id]
        with sqlite3.connect(DB_PATH) as conn:
            conn.execute("DELETE FROM taskmasters WHERE agent_id = ?", (agent_id,))
        logger.info(f"TaskMaster instance removed: {agent_id}")

    @classmethod
    def load_from_db(cls):
        with sqlite3.connect(DB_PATH) as conn:
            for agent_id, mission in conn.execute("SELECT agent_id, mission FROM taskmasters"):
                instance = AgentTaskMasterNextGeneration(agent_id=agent_id)
                cls.instances[agent_id] = instance
                asyncio.create_task(instance.create_task_from_natural_language(mission))
                logger.info(f"Restored TaskMaster: {agent_id}")

# --- API REST supervisée ---
app = FastAPI(title="TaskMaster Supervisor API")

class LaunchRequest(BaseModel):
    mission: str
    agent_id: Optional[str] = None

@app.on_event("startup")
async def restore_instances():
    TaskMasterRegistry.load_from_db()

@app.post("/launch")
async def launch_taskmaster(req: LaunchRequest):
    agent_id = req.agent_id or f"tm_{uuid4().hex[:6]}"
    instance = AgentTaskMasterNextGeneration(agent_id=agent_id)
    TaskMasterRegistry.register(agent_id, instance, req.mission)
    asyncio.create_task(instance.create_task_from_natural_language(req.mission))
    return {"status": "launched", "agent_id": agent_id}

@app.get("/instances")
def list_running():
    return {"running_instances": TaskMasterRegistry.list_instances()}

@app.get("/instances/{agent_id}")
def get_instance(agent_id: str):
    instance = TaskMasterRegistry.get(agent_id)
    if not instance:
        raise HTTPException(status_code=404, detail="Instance not found")
    return {"agent_id": agent_id, "status": "running"}

@app.delete("/instances/{agent_id}")
def stop_instance(agent_id: str):
    TaskMasterRegistry.remove(agent_id)
    return {"status": "terminated", "agent_id": agent_id}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("taskmaster_pool_supervisor:app", host="0.0.0.0", port=8001, reload=True)
