#!/usr/bin/env python3
"""
üîç AGENT 2 - √âVALUATEUR D'UTILIT√â AM√âLIOR√â (NextGeneration + TOP)
=================================================================
Mission: √âvaluer l'utilit√© des outils analys√©s avec intelligence multi-crit√®res avanc√©e

üöÄ AM√âLIORATIONS INT√âGR√âES DE L'√âQUIPE TOP:
- üß† Syst√®me d'√©valuation multi-crit√®res pond√©r√©s
- üéØ Mots-cl√©s NextGeneration sp√©cialis√©s (high/medium/low priority)
- ‚öñÔ∏è √âvaluation 5 dimensions: technique, architecture, valeur, int√©gration, maintenance
- üîç D√©tection automatique conflits et redondances
- üìä Algorithme de similarit√© entre outils
- üéØ Priorisation intelligente bas√©e sur scores composites
- üèÜ Support √©valuation sp√©cialis√©e (APEX, PowerShell, Batch)

Architecture Pattern Factory:
- H√©rite de Agent de base  
- Impl√©mente m√©thodes abstraites obligatoires
- Configuration NextGeneration int√©gr√©e
- Logging Pattern Factory standardis√©
"""

import json
import sys
from pathlib import Path
import asyncio
from datetime import datetime
from typing import Dict, List, Any, Optional
import re
import uuid

# --- Configuration Robuste du Chemin d'Importation ---
try:
    project_root = Path(__file__).resolve().parents[2]
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
except (IndexError, NameError):
    if '.' not in sys.path:
        sys.path.insert(0, '.')

from core import logging_manager
from agent_factory_implementation.core.agent_factory_architecture import Agent, Task, Result

class AgentMAINTENANCE02EvaluateurUtilite(Agent):
    """
    Agent charg√© d'√©valuer l'utilit√© et la pertinence d'un fichier de code.
    Il v√©rifie si le code est un placeholder, un vrai agent, ou vide.
    """
    def __init__(self, agent_id="agent_MAINTENANCE_02_evaluateur_utilite", version="1.0", description="√âvalue l'utilit√© d'un fichier de code.", status="enabled"):
        super().__init__(agent_id, version, description, "evaluator", status)
        # Regex pour d√©tecter les signes de code "placeholder" ou non-impl√©ment√©
        self.placeholder_patterns = [
            re.compile(r'^\s*pass\s*$', re.MULTILINE),
            re.compile(r'raise\s+NotImplementedError'),
            re.compile(r'#\s*TODO', re.IGNORECASE),
            re.compile(r'return\s+None', re.IGNORECASE)
        ]

    async def startup(self):
        await super().startup()
        self.log("√âvaluateur d'utilit√© pr√™t.")

    async def execute_task(self, task: Task) -> Result:
        if task.type != "evaluate_utility":
            return Result(success=False, error="Type de t√¢che non support√©.")

        code = task.params.get("code")
        file_path = task.params.get("file_path", "unknown_file")
        if code is None:
            return Result(success=False, error="Code non fourni.")

        self.log(f"√âvaluation du fichier : {file_path}")

        # 1. V√©rifier si le code est vide ou ne contient que des commentaires/espaces
        stripped_code = re.sub(r'#.*|\s', '', code)
        if not stripped_code:
            self.log(f"Fichier {file_path} est vide ou ne contient pas de code fonctionnel.")
            return Result(success=False, error="Le code est vide.", data={"evaluation": "empty"})

        # 2. V√©rifier les patterns de code placeholder
        placeholder_score = 0
        for pattern in self.placeholder_patterns:
            if pattern.search(code):
                placeholder_score += 1
        
        # 3. V√©rifier la complexit√© (tr√®s basique)
        num_lines = len([line for line in code.splitlines() if line.strip()])
        num_functions = code.count("def ")
        num_classes = code.count("class ")

        # Heuristique simple pour d√©cider
        if num_lines < 10 and num_functions < 2 and placeholder_score > 0:
            self.log(f"Fichier {file_path} semble √™tre un placeholder.")
            return Result(success=False, error="Le code est un placeholder.", data={"evaluation": "placeholder", "score": placeholder_score})

        # Si aucune condition d'inutilit√© n'est remplie
        self.log(f"Fichier {file_path} semble √™tre un agent utile.")
        return Result(success=True, data={
            "evaluation": "useful", 
            "lines": num_lines, 
            "functions": num_functions,
            "classes": num_classes,
            "placeholder_score": placeholder_score
        })

def create_agent_MAINTENANCE_02_evaluateur_utilite(**config) -> AgentMAINTENANCE02EvaluateurUtilite:
    """Factory pour cr√©er une instance de l'Agent 2."""
    return AgentMAINTENANCE02EvaluateurUtilite(**config)

if __name__ == "__main__":
    async async def main():
        print("üß† AGENT 2 - √âVALUATEUR D'UTILIT√â AM√âLIOR√â")
        agent = create_agent_MAINTENANCE_02_evaluateur_utilite()
        await agent.startup()
        await agent.shutdown()
    asyncio.run(main()) 
