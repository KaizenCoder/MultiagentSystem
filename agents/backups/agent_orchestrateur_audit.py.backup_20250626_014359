#!/usr/bin/env python3
"""

# ğŸ”§ CONVERTI AUTOMATIQUEMENT SYNC â†’ ASYNC
# Date: 2025-06-19 19h35 - Correction architecture Pattern Factory
# Raison: Harmonisation async/sync avec core/agent_factory_architecture.py

ğŸ¯ AGENT ORCHESTRATEUR AUDIT - Coordination Ã‰quipe Auditeurs
Mission : Orchestration complÃ¨te de l'Ã©quipe d'agents auditeurs spÃ©cialisÃ©s

ResponsabilitÃ©s :
- Coordination Agent 18 (SÃ©curitÃ©), Agent 19 (Performance), Agent 20 (ConformitÃ©)
- Orchestration audits parallÃ¨les et sÃ©quentiels
- Consolidation rapports d'audit
- GÃ©nÃ©ration rapport exÃ©cutif global
- Priorisation des actions correctives
- Suivi des amÃ©liorations
"""

import asyncio
import sys
from pathlib import Path
from core import logging_manager
from datetime import datetime
from typing import Dict, List, Optional, Any
from pathlib import Path
import json
import sys
from dataclasses import dataclass
from enum import Enum
import logging

# Import des agents auditeurs
sys.path.insert(0, str(Path(__file__).parent))

try:
    from agent_18_auditeur_securite import Agent18AuditeurSecurite
    AGENT_18_AVAILABLE = True
except ImportError:
    AGENT_18_AVAILABLE = False

try:
    from agent_19_auditeur_performance import Agent19AuditeurPerformance
    AGENT_19_AVAILABLE = True
except ImportError:
    AGENT_19_AVAILABLE = False

class AuditPhase(Enum):
    PREPARATION = "prÃ©paration"
    EXECUTION = "exÃ©cution"
    CONSOLIDATION = "consolidation"
    REPORTING = "rapport"
    COMPLETE = "terminÃ©"

class AuditPriority(Enum):
    CRITIQUE = "critique"
    HAUTE = "haute"
    MOYENNE = "moyenne"
    BASSE = "basse"

@dataclass
class AuditTask:
    task_id: str
    agent_type: str
    target: str
    priority: AuditPriority
    status: str
    result: Optional[Dict[str, Any]] = None

class AgentOrchestrateurAudit:
    """
    ğŸ¯ Agent Orchestrateur Audit
    
    Coordonne l'Ã©quipe complÃ¨te d'agents auditeurs spÃ©cialisÃ©s
    pour des audits complets et coordonnÃ©s
    """
    
    def __init__(self, workspace_root: Path = None):
        self.agent_id = "ORCHESTRATEUR_AUDIT"
        self.specialite = "Orchestration Audit Multi-Agents"
        self.workspace_root = workspace_root if workspace_root else Path(__file__).parent.parent
        
        self.logger = self._setup_logging()

        # Initialisation agents disponibles
        self.agents = {}
        self._initialize_agents()
        
        # Ã‰tat de l'orchestration
        self.current_phase = AuditPhase.PREPARATION
        self.audit_tasks = []
        self.consolidated_results = {}
        
        # Configuration audit
        self.audit_config = {
            'parallel_execution': True,
            'timeout_minutes': 30,
            'retry_on_failure': True,
            'generate_executive_summary': True
        }
        
        self.logger.info(f"ğŸ¯ Orchestrateur Audit initialisÃ© avec {len(self.agents)} agents")

    def _initialize_agents(self):
        """Initialisation des agents auditeurs disponibles"""
        
        if AGENT_18_AVAILABLE:
            try:
                self.agents['securite'] = Agent18AuditeurSecurite()
                self.logger.info("âœ… Agent 18 SÃ©curitÃ© chargÃ©")
            except Exception as e:
                self.logger.warning(f"âš ï¸ Erreur chargement Agent 18: {e}")
        
        if AGENT_19_AVAILABLE:
            try:
                self.agents['performance'] = Agent19AuditeurPerformance()
                self.logger.info("âœ… Agent 19 Performance chargÃ©")
            except Exception as e:
                self.logger.warning(f"âš ï¸ Erreur chargement Agent 19: {e}")
        
        # Agent 20 (Ã  implÃ©menter si disponible)
        # try:
        #     from agent_20_auditeur_conformite import Agent20AuditeurConformite
        #     self.agents['conformite'] = Agent20AuditeurConformite()
        #     self.logger.info("âœ… Agent 20 ConformitÃ© chargÃ©")
        # except ImportError:
        #     self.logger.info("â„¹ï¸ Agent 20 ConformitÃ© non disponible")

    def _setup_logging(self):
        """Configuration du logging pour l'orchestrateur."""
        logger = logging.getLogger(f"OrchestrateurAudit.{self.agent_id}")
        logger.setLevel(logging.INFO)
        
        if not logger.handlers:
            log_dir = self.workspace_root / "logs" / "agents" / "orchestrateur_audit"
            log_dir.mkdir(parents=True, exist_ok=True)
            
            log_file = log_dir / f"audit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
            
            # Handler Fichier
            file_handler = logging.FileHandler(log_file, encoding='utf-8')
            file_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            file_handler.setFormatter(file_formatter)
            logger.addHandler(file_handler)
            
            # Handler Console
            console_handler = logging.StreamHandler(sys.stdout)
            console_formatter = logging.Formatter('ğŸ•µï¸â€ (Orchestrateur) - %(levelname)s - %(message)s')
            console_handler.setFormatter(console_formatter)
            logger.addHandler(console_handler)
            
        return logger

    async def executer_audit_complet(self, targets: List[str]) -> Dict[str, Any]:
        """
    ğŸš€ ExÃ©cution audit complet multi-agents
        
    Args:
    targets: Liste des cibles Ã  auditer
            
    Returns:
    Rapport consolidÃ© de tous les audits
        """
    self.logger.info(f"ğŸš€ DÃ©marrage audit complet sur {len(targets)} cibles")
        
    audit_id = f"AUDIT_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
    try:
            # Phase 1: PrÃ©paration
    self.current_phase = AuditPhase.PREPARATION
    await self._prepare_audit_tasks(targets)
            
            # Phase 2: ExÃ©cution
    self.current_phase = AuditPhase.EXECUTION
    await self._execute_audit_tasks()
            
            # Phase 3: Consolidation
    self.current_phase = AuditPhase.CONSOLIDATION
    consolidated_report = await self._consolidate_results()
            
            # Phase 4: Rapport exÃ©cutif
    self.current_phase = AuditPhase.REPORTING
    executive_report = await self._generate_executive_report(audit_id, consolidated_report)
            
    self.current_phase = AuditPhase.COMPLETE
            
            # Sauvegarde rapport final
    await self._save_orchestrator_report(executive_report)
            
    self.logger.info("âœ… Audit complet terminÃ© avec succÃ¨s")
    return executive_report
            
    except Exception as e:
    self.logger.error(f"âŒ Erreur audit complet: {e}")
    return {
    'status': 'ERROR',
    'audit_id': audit_id,
    'error': str(e),
    'phase': self.current_phase.value,
    'timestamp': datetime.now().isoformat()
    }

    async def _prepare_audit_tasks(self, targets: List[str]):
        """PrÃ©paration des tÃ¢ches d'audit"""
    self.logger.info("ğŸ“‹ PrÃ©paration des tÃ¢ches d'audit")
        
    self.audit_tasks = []
    task_counter = 0
        
    for target in targets:
    target_path = Path(target)
            
    if not target_path.exists():
    self.logger.warning(f"âš ï¸ Cible inexistante ignorÃ©e: {target}")
    continue
            
            # DÃ©termination prioritÃ© basÃ©e sur le type de cible
    if target_path.name in ['core', 'main', 'src']:
    priority = AuditPriority.CRITIQUE
    elif target_path.suffix == '.py':
    priority = AuditPriority.HAUTE
    else:
    priority = AuditPriority.MOYENNE
            
            # CrÃ©ation tÃ¢che pour chaque agent disponible
    for agent_type in self.agents.keys():
    task_counter += 1
    task = AuditTask(
    task_id=f"TASK_{task_counter:03d}",
    agent_type=agent_type,
    target=target,
    priority=priority,
    status="prÃ©parÃ©"
    )
    self.audit_tasks.append(task)
        
    self.logger.info(f"ğŸ“‹ {len(self.audit_tasks)} tÃ¢ches prÃ©parÃ©es pour {len(self.agents)} agents")

    async def _execute_audit_tasks(self):
        """ExÃ©cution des tÃ¢ches d'audit"""
    self.logger.info("âš¡ ExÃ©cution des tÃ¢ches d'audit")
        
    if self.audit_config['parallel_execution']:
    await self._execute_parallel()
    else:
    await self._execute_sequential()

    async def _execute_parallel(self):
        """ExÃ©cution parallÃ¨le des audits"""
    self.logger.info("ğŸ”„ ExÃ©cution parallÃ¨le des audits")
        
        # Groupement des tÃ¢ches par agent
    tasks_by_agent = {}
    for task in self.audit_tasks:
    if task.agent_type not in tasks_by_agent:
    tasks_by_agent[task.agent_type] = []
    tasks_by_agent[task.agent_type].append(task)
        
        # ExÃ©cution parallÃ¨le par agent
    coroutines = []
    for agent_type, agent_tasks in tasks_by_agent.items():
    coroutines.append(self._execute_agent_tasks(agent_type, agent_tasks))
        
        # Attente de toutes les exÃ©cutions
    await asyncio.gather(*coroutines, return_exceptions=True)

    async def _execute_sequential(self):
        """ExÃ©cution sÃ©quentielle des audits"""
    self.logger.info("ğŸ“ ExÃ©cution sÃ©quentielle des audits")
        
        # Tri par prioritÃ©
    sorted_tasks = sorted(self.audit_tasks, key=lambda t: list(AuditPriority).index(t.priority))
        
    for task in sorted_tasks:
    await self._execute_single_task(task)

    async def _execute_agent_tasks(self, agent_type: str, tasks: List[AuditTask]):
        """ExÃ©cution des tÃ¢ches pour un agent spÃ©cifique"""
        
    if agent_type not in self.agents:
    self.logger.error(f"âŒ Agent {agent_type} non disponible")
    return
        
    agent = self.agents[agent_type]
        
    for task in tasks:
    await self._execute_single_task(task)

    async def _execute_single_task(self, task: AuditTask):
        """ExÃ©cution d'une tÃ¢che individuelle"""
        
    try:
    self.logger.info(f"ğŸ” ExÃ©cution {task.task_id}: {task.agent_type} sur {task.target}")
            
    task.status = "en_cours"
    agent = self.agents[task.agent_type]
            
            # Appel de la mÃ©thode d'audit appropriÃ©e
    if task.agent_type == 'securite':
    result = await agent.auditer_securite_complete(task.target)
    elif task.agent_type == 'performance':
    result = await agent.auditer_performance(task.target)
    elif task.agent_type == 'conformite':
    result = await agent.auditer_conformite_complete(task.target)
    else:
    result = {'error': f'Type d\'agent non supportÃ©: {task.agent_type}'}
            
    task.result = result
    task.status = "terminÃ©"
            
    self.logger.info(f"âœ… {task.task_id} terminÃ© avec succÃ¨s")
            
    except Exception as e:
    self.logger.error(f"âŒ Erreur {task.task_id}: {e}")
    task.status = "erreur"
    task.result = {'error': str(e)}

    async def _consolidate_results(self) -> Dict[str, Any]:
        """Consolidation des rÃ©sultats de tous les agents"""
    self.logger.info("ğŸ“Š Consolidation des rÃ©sultats")
        
    consolidated = {
    'summary': {
    'total_tasks': len(self.audit_tasks),
    'successful_tasks': 0,
    'failed_tasks': 0,
    'tasks_by_agent': {},
    'tasks_by_priority': {}
    },
    'results_by_agent': {},
    'results_by_target': {},
    'global_metrics': {}
    }
        
        # Consolidation par agent
    for task in self.audit_tasks:
    agent_type = task.agent_type
            
            # Compteurs
    if task.status == "terminÃ©":
    consolidated['summary']['successful_tasks'] += 1
    else:
    consolidated['summary']['failed_tasks'] += 1
            
            # Par agent
    if agent_type not in consolidated['summary']['tasks_by_agent']:
    consolidated['summary']['tasks_by_agent'][agent_type] = 0
    consolidated['summary']['tasks_by_agent'][agent_type] += 1
            
            # Par prioritÃ©
    priority = task.priority.value
    if priority not in consolidated['summary']['tasks_by_priority']:
    consolidated['summary']['tasks_by_priority'][priority] = 0
    consolidated['summary']['tasks_by_priority'][priority] += 1
            
            # RÃ©sultats par agent
    if agent_type not in consolidated['results_by_agent']:
    consolidated['results_by_agent'][agent_type] = []
    consolidated['results_by_agent'][agent_type].append({
    'task_id': task.task_id,
    'target': task.target,
    'status': task.status,
    'result': task.result
    })
            
            # RÃ©sultats par cible
    target = task.target
    if target not in consolidated['results_by_target']:
    consolidated['results_by_target'][target] = {}
    consolidated['results_by_target'][target][agent_type] = task.result
        
        # MÃ©triques globales
    consolidated['global_metrics'] = await self._calculate_global_metrics()
        
    self.consolidated_results = consolidated
    return consolidated

    async def _calculate_global_metrics(self) -> Dict[str, Any]:
        """Calcul des mÃ©triques globales"""
        
    metrics = {
    'security_score': 0.0,
    'performance_score': 0.0,
    'conformity_score': 0.0,
    'global_score': 0.0,
    'critical_issues': 0,
    'total_issues': 0,
    'recommendations_count': 0
    }
        
    scores = []
        
    for task in self.audit_tasks:
    if task.status == "terminÃ©" and task.result:
    result = task.result
                
                # Extraction scores selon le type d'agent
    if task.agent_type == 'securite' and 'security_score' in result:
    metrics['security_score'] = max(metrics['security_score'], result['security_score'])
    scores.append(result['security_score'])
                    
    elif task.agent_type == 'performance' and 'score' in result:
    metrics['performance_score'] = max(metrics['performance_score'], result['score'])
    scores.append(result['score'])
                    
    elif task.agent_type == 'conformite' and 'conformity_score' in result:
    metrics['conformity_score'] = max(metrics['conformity_score'], result['conformity_score'])
    scores.append(result['conformity_score'])
                
                # Comptage issues
    if 'findings' in result:
    metrics['total_issues'] += len(result['findings'])
                    # Compter critiques (selon structure)
    critical_findings = [f for f in result['findings'] if 'critical' in str(f).lower()]
    metrics['critical_issues'] += len(critical_findings)
                
    if 'issues' in result:
    metrics['total_issues'] += len(result['issues'])
                
    if 'recommendations' in result:
    metrics['recommendations_count'] += len(result['recommendations'])
        
        # Score global (moyenne des scores disponibles)
    if scores:
    metrics['global_score'] = round(sum(scores) / len(scores), 1)
        
    return metrics

    async def _generate_executive_report(self, audit_id: str, consolidated: Dict[str, Any]) -> Dict[str, Any]:
        """GÃ©nÃ©ration du rapport exÃ©cutif"""
    self.logger.info("ğŸ“‹ GÃ©nÃ©ration du rapport exÃ©cutif")
        
    metrics = consolidated['global_metrics']
        
    executive_report = {
    'audit_id': audit_id,
    'timestamp': datetime.now().isoformat(),
    'orchestrator': {
    'agent_id': self.agent_id,
    'phase': self.current_phase.value,
    'agents_deployed': list(self.agents.keys()),
    'total_tasks': len(self.audit_tasks)
    },
            
    'executive_summary': {
    'global_score': metrics['global_score'],
    'security_assessment': self._get_assessment_level(metrics['security_score']),
    'performance_assessment': self._get_assessment_level(metrics['performance_score']),
    'conformity_assessment': self._get_assessment_level(metrics['conformity_score']),
    'critical_issues_count': metrics['critical_issues'],
    'total_issues_count': metrics['total_issues'],
    'overall_status': self._determine_overall_status(metrics)
    },
            
    'detailed_results': consolidated,
            
    'priority_actions': self._generate_priority_actions(consolidated),
            
    'recommendations': self._generate_consolidated_recommendations(consolidated),
            
    'next_steps': [
    "ğŸ”´ Traiter immÃ©diatement les issues critiques",
    "ğŸŸ¡ Planifier correction des problÃ¨mes majeurs",
    "ğŸ”„ Mettre en place monitoring continu",
    "ğŸ“… Programmer prochain audit dans 30 jours"
    ]
    }
        
    return executive_report

    def _get_assessment_level(self, score: float) -> str:
        """DÃ©termine le niveau d'Ã©valuation basÃ© sur le score"""
    if score >= 9.0:
    return "Excellent"
    elif score >= 7.0:
    return "Bon"
    elif score >= 5.0:
    return "Moyen"
    elif score >= 3.0:
    return "Faible"
    else:
    return "Critique"

    def _determine_overall_status(self, metrics: Dict[str, Any]) -> str:
        """DÃ©termine le statut global"""
    global_score = metrics['global_score']
    critical_issues = metrics['critical_issues']
        
    if critical_issues > 0:
    return "ğŸš¨ ACTION IMMÃ‰DIATE REQUISE"
    elif global_score >= 8.0:
    return "âœ… CONFORME"
    elif global_score >= 6.0:
    return "âš ï¸ AMÃ‰LIORATIONS NÃ‰CESSAIRES"
    else:
    return "âŒ NON CONFORME"

    def _generate_priority_actions(self, consolidated: Dict[str, Any]) -> List[str]:
        """GÃ©nÃ¨re les actions prioritaires"""
    actions = []
        
        # Analyse des rÃ©sultats par agent
    for agent_type, agent_results in consolidated['results_by_agent'].items():
    for agent_result in agent_results:
    if agent_result['status'] == 'terminÃ©' and agent_result['result']:
    result = agent_result['result']
                    
                    # Actions basÃ©es sur les findings critiques
    if 'findings' in result:
        critical_findings = [
            f for f in result['findings'] 
            if hasattr(f, 'security_level') and 'critical' in str(f.security_level).lower()
        ]
        if critical_findings:
            actions.append(f"ğŸš¨ {agent_type.upper()}: {len(critical_findings)} vulnÃ©rabilitÃ©(s) critique(s) Ã  corriger")
                    
                    # Actions basÃ©es sur les bottlenecks
    if 'bottlenecks' in result and result['bottlenecks']:
        actions.append(f"âš¡ {agent_type.upper()}: RÃ©soudre {len(result['bottlenecks'])} goulot(s) d'Ã©tranglement")
        
        # Actions gÃ©nÃ©rales si peu d'actions spÃ©cifiques
    if len(actions) < 3 and len(self.audit_tasks) > 0:
        actions.extend([
        "ğŸ” Effectuer audit approfondi des composants critiques",
        "ğŸ“š AmÃ©liorer la documentation technique",
        "ğŸ”§ Mettre Ã  jour les dÃ©pendances obsolÃ¨tes"
        ])
        
    return actions[:5]  # Top 5 actions

    def _generate_consolidated_recommendations(self, consolidated: Dict[str, Any]) -> List[str]:
        """GÃ©nÃ¨re les recommandations consolidÃ©es"""
    all_recommendations = set()
        
        # Collecte toutes les recommandations
    for agent_type, agent_results in consolidated['results_by_agent'].items():
    for agent_result in agent_results:
    if agent_result['status'] == 'terminÃ©' and agent_result['result']:
    result = agent_result['result']
                    
    if 'recommendations' in result:
        all_recommendations.update(result['recommendations'])
        
        # Recommandations orchestrateur
    orchestrator_recs = [
    "ğŸ¯ Mettre en place un processus d'audit continu",
    "ğŸ“Š ImplÃ©menter tableau de bord de qualitÃ©",
    "ğŸ”„ Automatiser les vÃ©rifications de conformitÃ©",
    "ğŸ‘¥ Former l'Ã©quipe aux bonnes pratiques",
    "ğŸ“ Documenter les procÃ©dures d'audit"
    ]
        
    all_recommendations.update(orchestrator_recs)
        
    return list(all_recommendations)

    async def _save_orchestrator_report(self, report: Dict[str, Any]):
        """Sauvegarde le rapport de l'orchestrateur"""
    try:
    reports_dir = self.workspace_root / "reports" / "orchestrateur_audit"
    reports_dir.mkdir(parents=True, exist_ok=True)
            
    report_file = reports_dir / f"orchestrator_audit_{report['audit_id']}.json"
            
    with open(report_file, 'w', encoding='utf-8') as f:
    json.dump(report, f, indent=2, ensure_ascii=False, default=str)
            
    self.logger.info(f"ğŸ“„ Rapport orchestrateur sauvegardÃ© : {report_file}")
            
    except Exception as e:
    self.logger.error(f"âŒ Erreur sauvegarde rapport orchestrateur : {e}")

async def main():
    """DÃ©monstration de l'orchestrateur d'audit"""
    print("ğŸ¯ ORCHESTRATEUR AUDIT - DÃ©monstration")
    
    # Initialisation orchestrateur
    orchestrateur = AgentOrchestrateurAudit()
    
    # DÃ©finition des cibles d'audit
    targets = [
    "core",
    "agents"
    ]
    
    # Filtrage des cibles existantes
    existing_targets = [str(orchestrateur.workspace_root / target) for target in targets if (orchestrateur.workspace_root / target).exists()]
    
    if not existing_targets:
    print(f"âŒ Aucune cible d'audit trouvÃ©e aux emplacements prÃ©vus (depuis {orchestrateur.workspace_root})")
    return
    
    print(f"\\nğŸ¯ DÃ©marrage audit sur {len(existing_targets)} cibles:")
    for target in existing_targets:
    print(f"  ğŸ“ {target}")
    
    # ExÃ©cution audit complet
    try:
    rapport = await orchestrateur.executer_audit_complet(existing_targets)
        
    print(f"\\nğŸ“Š === RAPPORT EXÃ‰CUTIF AUDIT ===")
    print(f"ğŸ†” ID Audit: {rapport['audit_id']}")
    print(f"ğŸ“ˆ Score Global: {rapport['executive_summary']['global_score']}/10")
    print(f"ğŸ¯ Statut: {rapport['executive_summary']['overall_status']}")
        
        # DÃ©tails par domaine
    print(f"\\nğŸ“‹ Ã‰VALUATIONS PAR DOMAINE:")
    summary = rapport['executive_summary']
    print(f"  ğŸ” SÃ©curitÃ©: {summary['security_assessment']}")
    print(f"  âš¡ Performance: {summary['performance_assessment']}")
    print(f"  ğŸ“‹ ConformitÃ©: {summary['conformity_assessment']}")
        
        # Issues critiques
    if summary['critical_issues_count'] > 0:
    print(f"\\nğŸš¨ ISSUES CRITIQUES: {summary['critical_issues_count']}")
        
        # Actions prioritaires
    if rapport['priority_actions']:
    print(f"\\nğŸ¯ ACTIONS PRIORITAIRES:")
    for action in rapport['priority_actions'][:3]:
    print(f"  {action}")
        
    print(f"\\nâœ… Audit orchestrÃ© terminÃ© avec succÃ¨s!")
    print(f"ğŸ“„ Rapport dÃ©taillÃ© sauvegardÃ©")
        
    except Exception as e:
    print(f"âŒ Erreur durant l'audit: {e}")

if __name__ == "__main__":
    asyncio.run(main()) 
