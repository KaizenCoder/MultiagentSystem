#!/usr/bin/env python3
"""
ü§ñ AGENT11AUDITEURQUALITE - PATTERN FACTORY NEXTGENERATION
========================================================

Mission: [Mission extraite de l'agent original]

Architecture Pattern Factory:
- H√©rite de Agent de base
- Impl√©mente m√©thodes abstraites obligatoires
- Configuration NextGeneration int√©gr√©e
- Logging Pattern Factory standardis√©

Transform√© automatiquement par Agent 03 Adaptateur Code Upgraded
Date: 2025-06-21 02:36:28
"""

import asyncio
import sys
import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional
import re
import ast

# Import Pattern Factory (OBLIGATOIRE selon guide)
# Assurez-vous que le chemin vers 'core' est dans le PYTHONPATH
try:
    from core.agent_factory_architecture import Agent, Task, Result
    from core import logging_manager
    PATTERN_FACTORY_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è Pattern Factory non disponible: {e}. Utilisation des classes de fallback.")
    PATTERN_FACTORY_AVAILABLE = False
    # Fallback classes si l'architecture centrale n'est pas disponible
    class Agent:
        def __init__(self, agent_type: str, **config):
            self.agent_id = f"fallback_{agent_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            self.agent_type = agent_type
            self.config = config
            logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            self.logger = logging.getLogger(self.agent_id)

        async def startup(self):
            self.logger.info(f"Agent {self.agent_id} d√©marr√© (fallback).")

        async def shutdown(self):
            self.logger.info(f"Agent {self.agent_id} arr√™t√© (fallback).")

        async def health_check(self):
            return {"status": "healthy_fallback"}

        def get_capabilities(self):
            return []

    class Task:
        def __init__(self, task_id: str, description: str, **kwargs):
            self.task_id = task_id
            self.description = description
            self.data = kwargs

    class Result:
        def __init__(self, success: bool, data: Any = None, error: str = None):
            self.success = success
            self.data = data
            self.error = error

# --- Helper Function pour une d√©tection de docstring robuste ---
def _has_module_docstring_manual(tree: ast.Module) -> bool:
    """V√©rifie manuellement la pr√©sence d'un docstring de module."""
    if not hasattr(tree, 'body') or not tree.body:
        return False
    
    first_node = tree.body[0]
    
    # Python < 3.8
    if sys.version_info < (3, 8) and isinstance(first_node, ast.Expr) and isinstance(first_node.value, ast.Str):
        return True
        
    # Python >= 3.8
    if sys.version_info >= (3, 8) and isinstance(first_node, ast.Expr) and isinstance(first_node.value, ast.Constant) and isinstance(first_node.value.value, str):
        return True
        
    return False

class Agent111AuditeurQualite(Agent):
    """Agent111AuditeurQualite - Pattern Factory NextGeneration"""

    def __init__(self, **config):
        # Pr√©-initialisation pour satisfaire les d√©pendances de la classe de base `Agent`
        self.agent_id = config.get("agent_id", f"agent_111_auditeur_qualite_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
        self.agent_type = "agent_111_auditeur_qualite"
        self.logger = logging.getLogger(f"Agent111AuditeurQualite_{self.agent_id}")
        
        # L'appel √† super() se fait APR√àS la cr√©ation des attributs dont il d√©pend.
        super().__init__(self.agent_type, **config)
        
        self.logger.info(f"ü§ñ Agent111AuditeurQualite initialis√© - ID: {self.agent_id}")
        
        # Ce code √©tait orphelin √† la fin du fichier, je le d√©place ici.
        self.workspace_root = Path(__file__).resolve().parents[1]
        self.code_expert_path = self.workspace_root / "code_expert"

        try:
            sys.path.insert(0, str(self.code_expert_path.parent))
            from code_expert.enhanced_agent_templates import AgentTemplate
            from code_expert.optimized_template_manager import OptimizedTemplateManager
            self.code_expert_available = True
            self.logger.info("[BOOT] Code expert Claude Phase 2 (templates, manager) charg√©.")
        except ImportError as e:
            self.code_expert_available = False
            self.logger.warning(f"[BOOT] Code expert non disponible: {e}")

        self.quality_report = {}
        self.dod_status = {}


    async def startup(self):
        """D√©marrage agent_111_auditeur_qualite"""
        self.logger.info(f"üöÄ Agent111AuditeurQualite {self.agent_id} - D√âMARRAGE")
        await super().startup()
        self.logger.info("‚úÖ Agent d√©marr√© avec succ√®s")

    async def shutdown(self):
        """Arr√™t agent_111_auditeur_qualite"""
        self.logger.info(f"üõë Agent111AuditeurQualite {self.agent_id} - ARR√äT")
        await super().shutdown()

    async def health_check(self) -> Dict[str, Any]:
        """V√©rification sant√© agent_111_auditeur_qualite"""
        return {
            "agent_id": self.agent_id,
            "agent_type": self.agent_type,
            "status": "healthy",
            "ready": True,
            "pattern_factory_available": PATTERN_FACTORY_AVAILABLE,
            "timestamp": datetime.now().isoformat()
        }

    async def _audit_code(self, code: str, file_path: str) -> Dict[str, Any]:
        """Effectue un audit de qualit√© robuste en utilisant l'AST."""
        self.logger.info(f"D√©but de l'audit de qualit√© AST pour {file_path}")
        
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            self.logger.error(f"Erreur de syntaxe dans {file_path}: {e}")
            return {
                "file_path": file_path,
                "quality_score": 0,
                "issues": [{"severity": "CRITICAL", "description": f"SyntaxError: {e}", "code": "SYNTAX_ERROR"}],
                "error": f"SyntaxError: {e}"
            }

        score = 100
        issues = []
        
        # 1. V√©rification du docstring de module
        has_module_docstring = _has_module_docstring_manual(tree)
        if not has_module_docstring:
            score -= 20
            issues.append({
                "severity": "HIGH", 
                "description": "Docstring de module manquant.",
                "code": "MISSING_MODULE_DOCSTRING"
            })

        # 2. V√©rification des docstrings de fonction et de classe
        total_funcs = 0
        total_classes = 0
        funcs_without_docstrings = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                total_classes +=1
                # On pourrait aussi v√©rifier les docstrings de classe ici
            
            if isinstance(node, ast.FunctionDef):
                total_funcs += 1
                if not ast.get_docstring(node):
                    self.logger.warning(f"Fonction '{node.name}' sans docstring.")
                    funcs_without_docstrings.append({"function": node.name})
        
        if funcs_without_docstrings:
            score -= len(funcs_without_docstrings) * 5
            issues.append({
                "severity": "MEDIUM", 
                "description": f"{len(funcs_without_docstrings)} fonction(s) sans docstring.",
                "code": "MISSING_FUNCTION_DOCSTRING",
                "details": funcs_without_docstrings
            })

        return {
            "file_path": file_path,
            "quality_score": max(0, score),
            "metrics": {
                "total_lines": len(code.splitlines()),
                "total_functions": total_funcs,
                "total_classes": total_classes,
                "module_docstring": "‚úÖ Oui" if has_module_docstring else "‚ùå Non",
                "functions_no_docstring": len(funcs_without_docstrings),
            },
            "issues": issues
        }

    async def audit_code_quality(self, file_path: str) -> Dict[str, Any]:
        """
        T√¢che publique pour auditer la qualit√© d'un fichier de code.
        """
        self.logger.info(f"Audit public de qualit√© demand√© pour {file_path}")
        try:
            code = Path(file_path).read_text(encoding='utf-8')
            report = await self._audit_code(code, file_path)
            return report
        except FileNotFoundError:
            self.logger.error(f"Fichier non trouv√© pour l'audit : {file_path}")
            return {"error": "File not found", "quality_score": 0}
        except Exception as e:
            self.logger.error(f"Erreur durant l'audit de {file_path}: {e}", exc_info=True)
            return {"error": str(e), "quality_score": 0}

    async def execute_task(self, task: Task) -> Result:
        """Ex√©cution des t√¢ches - Pattern Factory OBLIGATOIRE"""
        self.logger.info(f"üéØ Ex√©cution t√¢che: {task.type if hasattr(task, 'type') else task.description}")
        try:
            task_type = task.type if hasattr(task, 'type') else task.description
            task_params = task.params if hasattr(task, 'params') else task.data

            if task_type == "audit_code_quality":
                code = task_params.get('code')
                file_path = task_params.get('file_path')
                if not code or not file_path:
                    return Result(success=False, error="Code et file_path sont requis pour audit_code_quality.")
                
                report = await self._audit_code(code, file_path)
                return Result(success=True, data={"quality_report": report})

            elif task_type == "execute_mission":
                mission_data = task_params.get('mission_data', None)
                results = await self.execute_mission(mission_data)
                return Result(success=True, data={"mission_results": results})

            elif task_type == "process_data":
                data_to_process = task_params.get('data', None)
                if data_to_process is None:
                    return Result(success=False, error="Donn√©es requises pour 'process_data'")
                processed = await self.process_data(data_to_process)
                return Result(success=True, data=processed)

            else:
                return Result(success=False, error=f"T√¢che non reconnue: {task_type}")

        except Exception as e:
            self.logger.error(f"‚ùå Erreur ex√©cution t√¢che {task.type if hasattr(task, 'type') else task.task_id}: {e}", exc_info=True)
            return Result(success=False, error=str(e))

    def get_capabilities(self) -> List[str]:
        """Retourne les capacit√©s de l'agent"""
        return [
            "audit_code_quality",
            "execute_mission",
            "process_data",
            "health_monitoring",
            "pattern_factory_compliance"
        ]

    # M√©thodes m√©tier (√† adapter selon l'agent original)
    async def execute_mission(self, mission_data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Ex√©cution de la mission principale de l'agent"""
        self.logger.info("üéØ D√©but ex√©cution mission")
        try:
            # TODO: Impl√©menter la logique m√©tier sp√©cifique de l'agent original
            result = {
                "status": "completed",
                "timestamp": datetime.now().isoformat(),
                "agent_id": self.agent_id
            }
            self.logger.info("‚úÖ Mission termin√©e avec succ√®s")
            return result
        except Exception as e:
            self.logger.error(f"‚ùå Erreur mission: {e}", exc_info=True)
            return {"status": "error", "error": str(e)}

    async def process_data(self, data: Any) -> Dict[str, Any]:
        """Traitement des donn√©es sp√©cifique √† l'agent"""
        self.logger.info("üîÑ Traitement des donn√©es")
        try:
            # TODO: Impl√©menter le traitement sp√©cifique
            return {
                "processed": True,
                "data_type": type(data).__name__,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            self.logger.error(f"‚ùå Erreur traitement donn√©es: {e}", exc_info=True)
            return {"processed": False, "error": str(e)}

# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_111_auditeur_qualite(**config) -> 'Agent111AuditeurQualite':
    """Factory function pour cr√©er un Agent111AuditeurQualite conforme Pattern Factory"""
    return Agent111AuditeurQualite(**config)

# Test de l'agent si ex√©cut√© directement
async def main():
    """Test de l'agent Pattern Factory"""
    print("üöÄ D√©marrage test agent_111_auditeur_qualite...")
    agent = create_agent_111_auditeur_qualite()

    try:
        await agent.startup()
        health = await agent.health_check()
        print(f"üè• Health Check: {health}")

        # Test d'une t√¢che
        print("\nüî¨ Test de la t√¢che 'execute_mission'...")
        task = Task("test_mission_01", "execute_mission", data={'mission_data': None})
        result = await agent.execute_task(task)
        print(f"   R√©sultat: {'Succ√®s' if result.success else '√âchec'} - {result.data or result.error}")

        print("\nüî¨ Test de la t√¢che 'audit_code_quality'...")
        try:
            with open(__file__, "r", encoding="utf-8") as f:
                test_code = f.read()
            audit_task = Task(type="audit_code_quality", params={"code": test_code, "file_path": __file__})
            audit_result = await agent.execute_task(audit_task)
            print(f"   R√©sultat: {'Succ√®s' if audit_result.success else '√âchec'}")
            if audit_result.success:
                print(f"   Score de qualit√© de ce fichier: {audit_result.data['quality_report']['quality_score']}/100")
        except Exception as e:
            print(f"   Erreur durant le test d'audit: {e}")

    except Exception as e:
        print(f"‚ùå Erreur durant l'ex√©cution de l'agent: {e}")
    finally:
        await agent.shutdown()
        print("\n‚úÖ Test termin√©.")


if __name__ == "__main__":
    asyncio.run(main())


