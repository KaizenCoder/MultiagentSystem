#!/usr/bin/env python3
"""
# ğŸ”§ CONVERTI AUTOMATIQUEMENT SYNC â†’ ASYNC
# Date: 2025-06-19 19h35 - Correction architecture Pattern Factory
# Raison: Harmonisation async/sync avec core/agent_factory_architecture.py

ğŸ” AGENT 18 - AUDITEUR SÃ‰CURITÃ‰ SPÃ‰CIALISÃ‰
Mission : Audit de sÃ©curitÃ© approfondi et validation des vulnÃ©rabilitÃ©s

ResponsabilitÃ©s :
- Audit de sÃ©curitÃ© complet du code
- DÃ©tection des vulnÃ©rabilitÃ©s OWASP Top 10
- Validation des configurations de sÃ©curitÃ©
- ContrÃ´le des permissions et accÃ¨s
- Audit des dÃ©pendances et CVE
- Rapport de conformitÃ© sÃ©curitÃ©
"""

import asyncio
import sys
from pathlib import Path
import hashlib
import subprocess
import tempfile
from datetime import datetime
from typing import Dict, List, Optional, Any
import json
import re
from dataclasses import dataclass, asdict
from enum import Enum
import os
import logging

# Import dynamique pour Ã©viter les problÃ¨mes de chemin
try:
    from core import logging_manager
    from agent_config import AgentFactoryConfig, config_manager
except ImportError:
    # Ajustement du chemin si le script est exÃ©cutÃ© directement
    sys.path.append(str(Path(__file__).resolve().parents[1]))
    from core import logging_manager
    from agent_config import AgentFactoryConfig, config_manager


class SecurityLevel(Enum):
    """Niveaux de sÃ©curitÃ©"""
    CRITICAL = "critique"
    HIGH = "haut"
    MEDIUM = "moyen"
    LOW = "bas"
    SECURE = "sÃ©curisÃ©"

class VulnerabilityType(Enum):
    """Types de vulnÃ©rabilitÃ©s"""
    INJECTION = "injection"
    XSS = "xss"
    BROKEN_AUTH = "authentification_cassÃ©e"
    SENSITIVE_DATA = "donnÃ©es_sensibles"
    XXE = "xxe"
    BROKEN_ACCESS = "contrÃ´le_accÃ¨s_cassÃ©"
    MISCONFIGURATION = "mauvaise_configuration"
    INSECURE_DESERIALIZATION = "dÃ©sÃ©rialisation_non_sÃ©curisÃ©e"
    VULNERABLE_COMPONENTS = "composants_vulnÃ©rables"
    INSUFFICIENT_LOGGING = "journalisation_insuffisante"

@dataclass
class SecurityFinding:
    """RÃ©sultat d'audit de sÃ©curitÃ©"""
    finding_id: str
    vulnerability_type: VulnerabilityType
    security_level: SecurityLevel
    title: str
    description: str
    location: str
    line_number: Optional[int]
    cwe_id: Optional[str]
    cvss_score: Optional[float]
    remediation: str
    evidence: str

@dataclass
class SecurityReport:
    """Rapport complet d'audit de sÃ©curitÃ©"""
    audit_id: str
    target: str
    timestamp: datetime
    findings: List[SecurityFinding]
    security_score: float
    compliance_status: Dict[str, bool]
    recommendations: List[str]
    summary: Dict[str, int]

class Agent18AuditeurSecurite:
    """
    ğŸ” Agent 18 - Auditeur SÃ©curitÃ© SpÃ©cialisÃ©
    """
    
    def __init__(self, config: Optional[AgentFactoryConfig] = None):
        self.config = config if config else config_manager.get_config()
        self.agent_id = "18"
        self.specialite = "Audit SÃ©curitÃ© SpÃ©cialisÃ©"
        self.mission = "Audit sÃ©curitÃ© complet et dÃ©tection vulnÃ©rabilitÃ©s"
        self.logger = logging.getLogger(self.__class__.__name__)
        self._setup_logging()

        self.security_patterns = {
            'sql_injection': [r'\.execute\([^)]*\+', r'f".*{.*}.*".*execute', r'%.*%.*execute', r'cursor\.execute.*%'],
            'xss': [r'innerHTML\s*=', r'document\.write\(', r'eval\(', r'\.html\([^)]*\+'],
            'hardcoded_secrets': [r'password\s*=\s*["\'][^"\']+["\']', r'api_key\s*=\s*["\'][^"\']+["\']', r'secret\s*=\s*["\'][^"\']+["\']', r'token\s*=\s*["\'][^"\']+["\']'],
            'weak_crypto': [r'md5\(', r'sha1\(', r'DES\(', r'RC4\('],
            'file_traversal': [r'open\([^)]*\.\./[^)]*\)', r'os\.path\.join\([^)]*\.\./[^)]*\)', r'pathlib\.[^(]*\([^)]*\.\./[^)]*\)']
        }
        self.security_reports = {}
        self.rapport = {
            'agent_id': self.agent_id,
            'mission_status': 'INITIALISÃ‰',
            'audits_effectuÃ©s': [],
            'vulnÃ©rabilitÃ©s_dÃ©tectÃ©es': 0,
            'niveau_sÃ©curitÃ©_global': None,
            'conformitÃ©_owasp': {},
            'recommandations_critiques': []
        }

    def _setup_logging(self):
        log_dir = Path("logs/agents")
        log_dir.mkdir(parents=True, exist_ok=True)
        handler = logging.FileHandler(log_dir / f"agent_{self.agent_id}_securite.log")
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        if not self.logger.handlers:
            self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
        self.logger.info(f"ğŸ” Agent {self.agent_id} - {self.specialite} INITIALISÃ‰")

    async def auditer_securite_complete(self, target_path: str) -> SecurityReport:
        self.logger.info(f"ğŸ” DÃ©marrage audit sÃ©curitÃ© complet : {target_path}")
        audit_id = f"SEC_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        findings = []
        target = Path(target_path)

        if target.is_file():
            findings.extend(await self._audit_file_security(str(target)))
        elif target.is_dir():
            for file_path in target.rglob('*'):
                if file_path.is_file() and not self._should_skip_file(file_path):
                    findings.extend(await self._audit_file_security(str(file_path)))
        
        security_score = self._calculate_security_score(findings)
        compliance_status = self._check_owasp_compliance(findings)
        recommendations = self._generate_security_recommendations(findings)
        
        report = SecurityReport(
            audit_id=audit_id,
            target=target_path,
            timestamp=datetime.now(),
            findings=findings,
            security_score=security_score,
            compliance_status=compliance_status,
            recommendations=recommendations,
            summary=self._generate_findings_summary(findings)
        )
        self.security_reports[audit_id] = report
        await self._save_security_report(report)
        self.logger.info(f"âœ… Audit sÃ©curitÃ© terminÃ© - Score: {security_score:.1f}/10")
        return report

    async def _audit_file_security(self, file_path: str) -> List[SecurityFinding]:
        findings = []
        try:
            content = Path(file_path).read_text(encoding='utf-8', errors='ignore')
            for vuln_type, patterns in self.security_patterns.items():
                for pattern in patterns:
                    for match in re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE):
                        line_num = content[:match.start()].count('\n') + 1
                        finding = self._create_security_finding(vuln_type, f"Pattern suspect: {match.group()}", file_path, line_num, match.group())
                        findings.append(finding)
        except Exception as e:
            self.logger.error(f"âŒ Erreur audit fichier {file_path}: {e}", exc_info=True)
        return findings

    def _should_skip_file(self, file_path: Path) -> bool:
        skip_extensions = {'.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe'}
        skip_dirs = {'__pycache__', '.git', '.venv'}
        return file_path.suffix.lower() in skip_extensions or any(part in skip_dirs for part in file_path.parts)

    def _create_security_finding(self, vuln_type: str, title: str, location: str, line_number: Optional[int], evidence: str) -> SecurityFinding:
        type_mapping = {
            'sql_injection': VulnerabilityType.INJECTION, 'xss': VulnerabilityType.XSS,
            'hardcoded_secrets': VulnerabilityType.SENSITIVE_DATA, 'weak_crypto': VulnerabilityType.SENSITIVE_DATA,
            'file_traversal': VulnerabilityType.BROKEN_ACCESS
        }
        vulnerability_type = type_mapping.get(vuln_type, VulnerabilityType.MISCONFIGURATION)
        security_level = self._determine_security_level(vulnerability_type)
        finding_id = f"SEC_{hashlib.md5(f'{location}_{line_number}_{evidence}'.encode()).hexdigest()[:8]}"
        return SecurityFinding(
            finding_id=finding_id, vulnerability_type=vulnerability_type, security_level=security_level,
            title=title, description=f"Pattern suspect dÃ©tectÃ©: {evidence}", location=location,
            line_number=line_number, cwe_id=self._get_cwe_id(vulnerability_type),
            cvss_score=self._get_cvss_score(security_level), remediation=self._generate_remediation(vulnerability_type, evidence),
            evidence=evidence
        )

    def _determine_security_level(self, vuln_type: VulnerabilityType) -> SecurityLevel:
        if vuln_type in {VulnerabilityType.INJECTION, VulnerabilityType.INSECURE_DESERIALIZATION}: return SecurityLevel.CRITICAL
        if vuln_type in {VulnerabilityType.XSS, VulnerabilityType.SENSITIVE_DATA}: return SecurityLevel.HIGH
        return SecurityLevel.MEDIUM

    def _get_cwe_id(self, vuln_type: VulnerabilityType) -> Optional[str]:
        return {VulnerabilityType.INJECTION: "CWE-89", VulnerabilityType.XSS: "CWE-79"}.get(vuln_type)

    def _get_cvss_score(self, security_level: SecurityLevel) -> Optional[float]:
        return {SecurityLevel.CRITICAL: 9.5, SecurityLevel.HIGH: 7.5, SecurityLevel.MEDIUM: 5.5}.get(security_level)

    def _generate_remediation(self, vuln_type: VulnerabilityType, evidence: str) -> str:
        return {
            VulnerabilityType.INJECTION: "Utiliser des requÃªtes prÃ©parÃ©es.",
            VulnerabilityType.SENSITIVE_DATA: "Stocker les secrets dans un vault."
        }.get(vuln_type, "Consulter la documentation de sÃ©curitÃ©.")

    def _calculate_security_score(self, findings: List[SecurityFinding]) -> float:
        if not findings: return 10.0
        penalties = {SecurityLevel.CRITICAL: 3.0, SecurityLevel.HIGH: 2.0, SecurityLevel.MEDIUM: 1.0}
        total_penalty = sum(penalties.get(f.security_level, 0) for f in findings)
        return round(max(0.0, 10.0 - total_penalty), 1)

    def _check_owasp_compliance(self, findings: List[SecurityFinding]) -> Dict[str, bool]:
        owasp_map = {'A03_Injection': VulnerabilityType.INJECTION}
        return {cat: not any(f.vulnerability_type == v for f in findings) for cat, v in owasp_map.items()}

    def _generate_security_recommendations(self, findings: List[SecurityFinding]) -> List[str]:
        recs = set()
        if any(f.vulnerability_type == VulnerabilityType.INJECTION for f in findings):
            recs.add("ImplÃ©menter une validation stricte des entrÃ©es.")
        return list(recs)

    def _generate_findings_summary(self, findings: List[SecurityFinding]) -> Dict[str, int]:
        summary = {'total': len(findings), 'critique': 0, 'haut': 0, 'moyen': 0}
        for f in findings:
            if f.security_level == SecurityLevel.CRITICAL: summary['critique'] += 1
            elif f.security_level == SecurityLevel.HIGH: summary['haut'] += 1
            elif f.security_level == SecurityLevel.MEDIUM: summary['moyen'] += 1
        return summary

    async def _save_security_report(self, report: SecurityReport):
        reports_dir = Path("reports/security")
        reports_dir.mkdir(parents=True, exist_ok=True)
        report_file = reports_dir / f"security_report_{report.audit_id}.json"
        try:
            with open(report_file, 'w', encoding='utf-8') as f:
                json.dump(asdict(report), f, indent=2, default=str, ensure_ascii=False)
            self.logger.info(f"ğŸ“„ Rapport sÃ©curitÃ© sauvegardÃ© : {report_file}")
        except Exception as e:
            self.logger.error(f"âŒ Erreur sauvegarde rapport : {e}", exc_info=True)

async def main():
    print("ğŸ” DÃ©marrage Agent 18 - Auditeur SÃ©curitÃ© SpÃ©cialisÃ©")
    agent = Agent18AuditeurSecurite()
    test_target = "agents"
    if Path(test_target).exists():
        print(f"\nğŸ” Audit sÃ©curitÃ© : {test_target}")
        try:
            report = await agent.auditer_securite_complete(test_target)
            print(f"âœ… Audit terminÃ© - Score sÃ©curitÃ© : {report.security_score}/10")
            print(f"ğŸ“Š VulnÃ©rabilitÃ©s trouvÃ©es : {len(report.findings)}")
            critical = [f for f in report.findings if f.security_level == SecurityLevel.CRITICAL]
            if critical:
                print(f"ğŸš¨ {len(critical)} vulnÃ©rabilitÃ©(s) critique(s) dÃ©tectÃ©e(s) !")
        except Exception as e:
            print(f"âŒ Erreur audit {test_target}: {e}")

if __name__ == "__main__":
    asyncio.run(main())