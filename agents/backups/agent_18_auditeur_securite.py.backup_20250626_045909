#!/usr/bin/env python3
"""
# 🔧 CONVERTI AUTOMATIQUEMENT SYNC → ASYNC
# Date: 2025-06-19 19h35 - Correction architecture Pattern Factory
# Raison: Harmonisation async/sync avec core/agent_factory_architecture.py

🔐 AGENT 18 - AUDITEUR SÉCURITÉ SPÉCIALISÉ
Mission : Audit de sécurité approfondi et validation des vulnérabilités

Responsabilités :
- Audit de sécurité complet du code
- Détection des vulnérabilités OWASP Top 10
- Validation des configurations de sécurité
- Contrôle des permissions et accès
- Audit des dépendances et CVE
- Rapport de conformité sécurité
"""

import asyncio
import sys
from pathlib import Path
import hashlib
import subprocess
import tempfile
from datetime import datetime
from typing import Dict, List, Optional, Any
import json
import re
from dataclasses import dataclass, asdict
from enum import Enum
import os
import logging

# Import dynamique pour éviter les problèmes de chemin
try:
    from core import logging_manager
    from agent_config import AgentFactoryConfig, config_manager
except ImportError:
    # Ajustement du chemin si le script est exécuté directement
    sys.path.append(str(Path(__file__).resolve().parents[1]))
    from core import logging_manager
    from agent_config import AgentFactoryConfig, config_manager


class SecurityLevel(Enum):
    """Niveaux de sécurité"""
    CRITICAL = "critique"
    HIGH = "haut"
    MEDIUM = "moyen"
    LOW = "bas"
    SECURE = "sécurisé"

class VulnerabilityType(Enum):
    """Types de vulnérabilités"""
    INJECTION = "injection"
    XSS = "xss"
    BROKEN_AUTH = "authentification_cassée"
    SENSITIVE_DATA = "données_sensibles"
    XXE = "xxe"
    BROKEN_ACCESS = "contrôle_accès_cassé"
    MISCONFIGURATION = "mauvaise_configuration"
    INSECURE_DESERIALIZATION = "désérialisation_non_sécurisée"
    VULNERABLE_COMPONENTS = "composants_vulnérables"
    INSUFFICIENT_LOGGING = "journalisation_insuffisante"

@dataclass
class SecurityFinding:
    """Résultat d'audit de sécurité"""
    finding_id: str
    vulnerability_type: VulnerabilityType
    security_level: SecurityLevel
    title: str
    description: str
    location: str
    line_number: Optional[int]
    cwe_id: Optional[str]
    cvss_score: Optional[float]
    remediation: str
    evidence: str

@dataclass
class SecurityReport:
    """Rapport complet d'audit de sécurité"""
    audit_id: str
    target: str
    timestamp: datetime
    findings: List[SecurityFinding]
    security_score: float
    compliance_status: Dict[str, bool]
    recommendations: List[str]
    summary: Dict[str, int]

class Agent18AuditeurSecurite:
    """
    🔐 Agent 18 - Auditeur Sécurité Spécialisé
    """
    
    def __init__(self, config: Optional[AgentFactoryConfig] = None):
        self.config = config if config else config_manager.get_config()
        self.agent_id = "18"
        self.specialite = "Audit Sécurité Spécialisé"
        self.mission = "Audit sécurité complet et détection vulnérabilités"
        self.logger = logging.getLogger(self.__class__.__name__)
        self._setup_logging()

        self.security_patterns = {
            'sql_injection': [r'\.execute\([^)]*\+', r'f".*{.*}.*".*execute', r'%.*%.*execute', r'cursor\.execute.*%'],
            'xss': [r'innerHTML\s*=', r'document\.write\(', r'eval\(', r'\.html\([^)]*\+'],
            'hardcoded_secrets': [r'password\s*=\s*["\'][^"\']+["\']', r'api_key\s*=\s*["\'][^"\']+["\']', r'secret\s*=\s*["\'][^"\']+["\']', r'token\s*=\s*["\'][^"\']+["\']'],
            'weak_crypto': [r'md5\(', r'sha1\(', r'DES\(', r'RC4\('],
            'file_traversal': [r'open\([^)]*\.\./[^)]*\)', r'os\.path\.join\([^)]*\.\./[^)]*\)', r'pathlib\.[^(]*\([^)]*\.\./[^)]*\)']
        }
        self.security_reports = {}
        self.rapport = {
            'agent_id': self.agent_id,
            'mission_status': 'INITIALISÉ',
            'audits_effectués': [],
            'vulnérabilités_détectées': 0,
            'niveau_sécurité_global': None,
            'conformité_owasp': {},
            'recommandations_critiques': []
        }

    def _setup_logging(self):
        log_dir = Path("logs/agents")
        log_dir.mkdir(parents=True, exist_ok=True)
        handler = logging.FileHandler(log_dir / f"agent_{self.agent_id}_securite.log")
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        if not self.logger.handlers:
            self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
        self.logger.info(f"🔐 Agent {self.agent_id} - {self.specialite} INITIALISÉ")

    async def auditer_securite_complete(self, target_path: str) -> SecurityReport:
        self.logger.info(f"🔐 Démarrage audit sécurité complet : {target_path}")
        audit_id = f"SEC_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        findings = []
        target = Path(target_path)

        if target.is_file():
            findings.extend(await self._audit_file_security(str(target)))
        elif target.is_dir():
            for file_path in target.rglob('*'):
                if file_path.is_file() and not self._should_skip_file(file_path):
                    findings.extend(await self._audit_file_security(str(file_path)))
        
        security_score = self._calculate_security_score(findings)
        compliance_status = self._check_owasp_compliance(findings)
        recommendations = self._generate_security_recommendations(findings)
        
        report = SecurityReport(
            audit_id=audit_id,
            target=target_path,
            timestamp=datetime.now(),
            findings=findings,
            security_score=security_score,
            compliance_status=compliance_status,
            recommendations=recommendations,
            summary=self._generate_findings_summary(findings)
        )
        self.security_reports[audit_id] = report
        await self._save_security_report(report)
        self.logger.info(f"✅ Audit sécurité terminé - Score: {security_score:.1f}/10")
        return report

    async def _audit_file_security(self, file_path: str) -> List[SecurityFinding]:
        findings = []
        try:
            content = Path(file_path).read_text(encoding='utf-8', errors='ignore')
            for vuln_type, patterns in self.security_patterns.items():
                for pattern in patterns:
                    for match in re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE):
                        line_num = content[:match.start()].count('\n') + 1
                        finding = self._create_security_finding(vuln_type, f"Pattern suspect: {match.group()}", file_path, line_num, match.group())
                        findings.append(finding)
        except Exception as e:
            self.logger.error(f"❌ Erreur audit fichier {file_path}: {e}", exc_info=True)
        return findings

    def _should_skip_file(self, file_path: Path) -> bool:
        skip_extensions = {'.pyc', '.pyo', '.pyd', '.so', '.dll', '.exe'}
        skip_dirs = {'__pycache__', '.git', '.venv'}
        return file_path.suffix.lower() in skip_extensions or any(part in skip_dirs for part in file_path.parts)

    def _create_security_finding(self, vuln_type: str, title: str, location: str, line_number: Optional[int], evidence: str) -> SecurityFinding:
        type_mapping = {
            'sql_injection': VulnerabilityType.INJECTION, 'xss': VulnerabilityType.XSS,
            'hardcoded_secrets': VulnerabilityType.SENSITIVE_DATA, 'weak_crypto': VulnerabilityType.SENSITIVE_DATA,
            'file_traversal': VulnerabilityType.BROKEN_ACCESS
        }
        vulnerability_type = type_mapping.get(vuln_type, VulnerabilityType.MISCONFIGURATION)
        security_level = self._determine_security_level(vulnerability_type)
        finding_id = f"SEC_{hashlib.md5(f'{location}_{line_number}_{evidence}'.encode()).hexdigest()[:8]}"
        return SecurityFinding(
            finding_id=finding_id, vulnerability_type=vulnerability_type, security_level=security_level,
            title=title, description=f"Pattern suspect détecté: {evidence}", location=location,
            line_number=line_number, cwe_id=self._get_cwe_id(vulnerability_type),
            cvss_score=self._get_cvss_score(security_level), remediation=self._generate_remediation(vulnerability_type, evidence),
            evidence=evidence
        )

    def _determine_security_level(self, vuln_type: VulnerabilityType) -> SecurityLevel:
        if vuln_type in {VulnerabilityType.INJECTION, VulnerabilityType.INSECURE_DESERIALIZATION}: return SecurityLevel.CRITICAL
        if vuln_type in {VulnerabilityType.XSS, VulnerabilityType.SENSITIVE_DATA}: return SecurityLevel.HIGH
        return SecurityLevel.MEDIUM

    def _get_cwe_id(self, vuln_type: VulnerabilityType) -> Optional[str]:
        return {VulnerabilityType.INJECTION: "CWE-89", VulnerabilityType.XSS: "CWE-79"}.get(vuln_type)

    def _get_cvss_score(self, security_level: SecurityLevel) -> Optional[float]:
        return {SecurityLevel.CRITICAL: 9.5, SecurityLevel.HIGH: 7.5, SecurityLevel.MEDIUM: 5.5}.get(security_level)

    def _generate_remediation(self, vuln_type: VulnerabilityType, evidence: str) -> str:
        return {
            VulnerabilityType.INJECTION: "Utiliser des requêtes préparées.",
            VulnerabilityType.SENSITIVE_DATA: "Stocker les secrets dans un vault."
        }.get(vuln_type, "Consulter la documentation de sécurité.")

    def _calculate_security_score(self, findings: List[SecurityFinding]) -> float:
        if not findings: return 10.0
        penalties = {SecurityLevel.CRITICAL: 3.0, SecurityLevel.HIGH: 2.0, SecurityLevel.MEDIUM: 1.0}
        total_penalty = sum(penalties.get(f.security_level, 0) for f in findings)
        return round(max(0.0, 10.0 - total_penalty), 1)

    def _check_owasp_compliance(self, findings: List[SecurityFinding]) -> Dict[str, bool]:
        owasp_map = {'A03_Injection': VulnerabilityType.INJECTION}
        return {cat: not any(f.vulnerability_type == v for f in findings) for cat, v in owasp_map.items()}

    def _generate_security_recommendations(self, findings: List[SecurityFinding]) -> List[str]:
        recs = set()
        if any(f.vulnerability_type == VulnerabilityType.INJECTION for f in findings):
            recs.add("Implémenter une validation stricte des entrées.")
        return list(recs)

    def _generate_findings_summary(self, findings: List[SecurityFinding]) -> Dict[str, int]:
        summary = {'total': len(findings), 'critique': 0, 'haut': 0, 'moyen': 0}
        for f in findings:
            if f.security_level == SecurityLevel.CRITICAL: summary['critique'] += 1
            elif f.security_level == SecurityLevel.HIGH: summary['haut'] += 1
            elif f.security_level == SecurityLevel.MEDIUM: summary['moyen'] += 1
        return summary

    async def _save_security_report(self, report: SecurityReport):
        reports_dir = Path("reports/security")
        reports_dir.mkdir(parents=True, exist_ok=True)
        report_file = reports_dir / f"security_report_{report.audit_id}.json"
        try:
            with open(report_file, 'w', encoding='utf-8') as f:
                json.dump(asdict(report), f, indent=2, default=str, ensure_ascii=False)
            self.logger.info(f"📄 Rapport sécurité sauvegardé : {report_file}")
        except Exception as e:
            self.logger.error(f"❌ Erreur sauvegarde rapport : {e}", exc_info=True)

async def main():
    print("🔐 Démarrage Agent 18 - Auditeur Sécurité Spécialisé")
    agent = Agent18AuditeurSecurite()
    test_target = "agents"
    if Path(test_target).exists():
        print(f"\n🔍 Audit sécurité : {test_target}")
        try:
            report = await agent.auditer_securite_complete(test_target)
            print(f"✅ Audit terminé - Score sécurité : {report.security_score}/10")
            print(f"📊 Vulnérabilités trouvées : {len(report.findings)}")
            critical = [f for f in report.findings if f.security_level == SecurityLevel.CRITICAL]
            if critical:
                print(f"🚨 {len(critical)} vulnérabilité(s) critique(s) détectée(s) !")
        except Exception as e:
            print(f"❌ Erreur audit {test_target}: {e}")

if __name__ == "__main__":
    asyncio.run(main())