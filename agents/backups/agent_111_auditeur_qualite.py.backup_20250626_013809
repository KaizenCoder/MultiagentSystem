#!/usr/bin/env python3
"""
ü§ñ AGENT11AUDITEURQUALITE - PATTERN FACTORY NEXTGENERATION
========================================================

Mission: [Mission extraite de l'agent original]

Architecture Pattern Factory:
- H√©rite de Agent de base
- Impl√©mente m√©thodes abstraites obligatoires
- Configuration NextGeneration int√©gr√©e
- Logging Pattern Factory standardis√©

Transform√© automatiquement par Agent 03 Adaptateur Code Upgraded
Date: 2025-06-21 02:36:28
"""

import asyncio
import sys
import logging
import ast
import inspect
import importlib.util
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional, Union

# Import Pattern Factory (OBLIGATOIRE selon guide)
# Assurez-vous que le chemin vers 'core' est dans le PYTHONPATH
try:
    from core.agent_factory_architecture import Agent, Task, Result
    from core import logging_manager
    PATTERN_FACTORY_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è Pattern Factory non disponible: {e}. Utilisation des classes de fallback.")
    PATTERN_FACTORY_AVAILABLE = False
    # Fallback classes si l'architecture centrale n'est pas disponible
    class Agent:
        def __init__(self, agent_type: str, **config):
            self.agent_id = f"fallback_{agent_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            self.agent_type = agent_type
            self.config = config
            logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            self.logger = logging.getLogger(self.agent_id)

        async def startup(self):
            self.logger.info(f"Agent {self.agent_id} d√©marr√© (fallback).")

        async def shutdown(self):
            self.logger.info(f"Agent {self.agent_id} arr√™t√© (fallback).")

        async def health_check(self):
            return {"status": "healthy_fallback"}

        def get_capabilities(self):
            return []

    class Result:
        def __init__(self, success: bool, data: Any = None, error: str = None):
            self.success = success
            self.data = data
            self.error = error

class Agent111AuditeurQualite(Agent):
    """Agent111AuditeurQualite - Pattern Factory NextGeneration"""

    def __init__(self, **config):
        # Pr√©-initialisation pour satisfaire les d√©pendances de la classe de base `Agent`
        self.agent_id = config.get("agent_id", f"agent_111_auditeur_qualite_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
        self.agent_type = "agent_111_auditeur_qualite"
        self.logger = logging.getLogger(f"Agent111AuditeurQualite_{self.agent_id}")
        
        # L'appel √† super() se fait APR√àS la cr√©ation des attributs dont il d√©pend.
        super().__init__(self.agent_type, **config)
        
        self.logger.info(f"ü§ñ Agent111AuditeurQualite initialis√© - ID: {self.agent_id}")
        
        # Ce code √©tait orphelin √† la fin du fichier, je le d√©place ici.
        self.workspace_root = Path(__file__).resolve().parents[1]
        self.code_expert_path = self.workspace_root / "code_expert"

        try:
            sys.path.insert(0, str(self.code_expert_path.parent))
            from code_expert.enhanced_agent_templates import AgentTemplate
            from code_expert.optimized_template_manager import OptimizedTemplateManager
            self.code_expert_available = True
            self.logger.info("[BOOT] Code expert Claude Phase 2 (templates, manager) charg√©.")
        except ImportError as e:
            self.code_expert_available = False
            self.logger.warning(f"[BOOT] Code expert non disponible: {e}")

        self.quality_report = {}
        self.dod_status = {}
        
        # Module d'audit universel
        self.universal_auditor = UniversalAuditor(logger=self.logger)


    async def startup(self):
        """D√©marrage agent_111_auditeur_qualite"""
        self.logger.info(f"üöÄ Agent111AuditeurQualite {self.agent_id} - D√âMARRAGE")
        await super().startup()
        self.logger.info("‚úÖ Agent d√©marr√© avec succ√®s")

    async def shutdown(self):
        """Arr√™t agent_111_auditeur_qualite"""
        self.logger.info(f"üõë Agent111AuditeurQualite {self.agent_id} - ARR√äT")
        await super().shutdown()

    async def health_check(self) -> Dict[str, Any]:
        """V√©rification sant√© agent_111_auditeur_qualite"""
        return {
            "agent_id": self.agent_id,
            "agent_type": self.agent_type,
            "status": "healthy",
            "ready": True,
            "pattern_factory_available": PATTERN_FACTORY_AVAILABLE,
            "timestamp": datetime.now().isoformat()
        }

    async def execute_task(self, task: Task) -> Result:
        """Ex√©cution des t√¢ches - Pattern Factory OBLIGATOIRE"""
        self.logger.info(f"üéØ Ex√©cution t√¢che: type={getattr(task, 'type', None)} params={getattr(task, 'params', None)}")
        try:
            # Nouvelle logique compatible core
            if hasattr(task, 'type') and task.type == "execute_mission":
                mission_data = task.params.get('mission_data', None) if hasattr(task, 'params') else None
                results = await self.execute_mission(mission_data)
                return Result(success=True, data={"mission_results": results})

            elif hasattr(task, 'type') and task.type == "process_data":
                data_to_process = task.params.get('data', None) if hasattr(task, 'params') else None
                if data_to_process is None:
                    return Result(success=False, error="Donn√©es requises pour 'process_data'")
                processed = await self.process_data(data_to_process)
                return Result(success=True, data=processed)

            elif hasattr(task, 'type') and task.type == "generate_strategic_report":
                report_path = await self.generate_strategic_report(task.params)
                return Result(success=True, data={"report_path": str(report_path)})
                
            elif hasattr(task, 'type') and task.type == "audit_module":
                module_path = task.params.get('module_path') if hasattr(task, 'params') else None
                if not module_path:
                    return Result(success=False, error="Chemin du module requis pour l'audit")
                audit_result = await self.audit_python_module(module_path)
                return Result(success=True, data=audit_result)

            else:
                return Result(success=False, error=f"T√¢che non reconnue: {getattr(task, 'type', None)}")

        except Exception as e:
            self.logger.error(f"‚ùå Erreur ex√©cution t√¢che: {e}", exc_info=True)
            return Result(success=False, error=str(e))

    def get_capabilities(self) -> List[str]:
        """Retourne les capacit√©s de l'agent"""
        return [
            "execute_mission",
            "process_data",
            "health_monitoring",
            "pattern_factory_compliance",
            "audit_module",
            "universal_audit"
        ]

    # M√©thodes m√©tier (√† adapter selon l'agent original)
    async def execute_mission(self, mission_data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Ex√©cution de la mission principale de l'agent"""
        self.logger.info("üéØ D√©but ex√©cution mission")
        try:
            # TODO: Impl√©menter la logique m√©tier sp√©cifique de l'agent original
            result = {
                "status": "completed",
                "timestamp": datetime.now().isoformat(),
                "agent_id": self.agent_id
            }
            self.logger.info("‚úÖ Mission termin√©e avec succ√®s")
            return result
        except Exception as e:
            self.logger.error(f"‚ùå Erreur mission: {e}", exc_info=True)
            return {"status": "error", "error": str(e)}

    async def process_data(self, data: Any) -> Dict[str, Any]:
        """Traitement des donn√©es sp√©cifique √† l'agent"""
        self.logger.info("üîÑ Traitement des donn√©es")
        try:
            # TODO: Impl√©menter le traitement sp√©cifique
            return {
                "processed": True,
                "data_type": type(data).__name__,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            self.logger.error(f"‚ùå Erreur traitement donn√©es: {e}", exc_info=True)
            return {"processed": False, "error": str(e)}

    async def generate_strategic_report(self, params: dict = None) -> Path:
        """G√©n√®re un rapport strat√©gique simple dans le dossier de l'agent"""
        reports_dir = self.workspace_root / 'logs' / 'agents' / 'agent_111_auditeur_qualite' / 'reports'
        reports_dir.mkdir(parents=True, exist_ok=True)
        report_path = reports_dir / f"RAPPORT_STRATEGIQUE_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        content = f"""# Rapport Strat√©gique - Agent 111 Auditeur Qualit√©

Date : {datetime.now().isoformat()}

R√©sum√© :
- Agent ID : {self.agent_id}
- Param√®tres : {params}
- Statut : Succ√®s
"""
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(content)
        self.logger.info(f"üìù Rapport strat√©gique g√©n√©r√© : {report_path}")
        self.logger.info(f"[DEBUG] Chemin absolu du rapport : {report_path.resolve()}")
        return report_path

    async def audit_python_module(self, module_path: Union[str, Path]) -> Dict[str, Any]:
        """Audite un module Python de mani√®re universelle"""
        self.logger.info(f"üîç D√©but audit universel du module : {module_path}")
        try:
            audit_result = self.universal_auditor.analyze_module(module_path)
            self.logger.info(f"‚úÖ Audit termin√© pour : {module_path}")
            return audit_result
        except Exception as e:
            self.logger.error(f"‚ùå Erreur audit module {module_path}: {e}", exc_info=True)
            return {"error": str(e), "module_path": str(module_path)}

class UniversalAuditor:
    """Module d'audit universel pour analyser n'importe quel module Python"""
    
    def __init__(self, logger=None):
        self.logger = logger or logging.getLogger("UniversalAuditor")
        self.metrics = {}
        self.issues = []
        
    def analyze_module(self, module_path: Union[str, Path]) -> Dict[str, Any]:
        """Analyse compl√®te d'un module Python"""
        module_path = Path(module_path)
        
        if not module_path.exists():
            return {"error": f"Module non trouv√© : {module_path}"}
            
        try:
            with open(module_path, 'r', encoding='utf-8') as f:
                source_code = f.read()
        except Exception as e:
            return {"error": f"Erreur lecture fichier : {e}"}
            
        # Analyse AST
        try:
            tree = ast.parse(source_code, filename=str(module_path))
        except SyntaxError as e:
            return {"error": f"Erreur syntaxe : {e}"}
            
        # Collecte des m√©triques
        self.metrics = self._calculate_metrics(tree, source_code)
        self.issues = self._detect_issues(tree, source_code)
        
        return {
            "module_path": str(module_path),
            "timestamp": datetime.now().isoformat(),
            "metrics": self.metrics,
            "issues": self.issues,
            "quality_score": self._calculate_quality_score(),
            "recommendations": self._generate_recommendations()
        }
        
    def _calculate_metrics(self, tree: ast.AST, source_code: str) -> Dict[str, Any]:
        """Calcule les m√©triques de code"""
        lines = source_code.split('\n')
        
        # Compteurs
        visitor = MetricVisitor()
        visitor.visit(tree)
        
        return {
            "lines_of_code": len(lines),
            "blank_lines": len([l for l in lines if not l.strip()]),
            "comment_lines": len([l for l in lines if l.strip().startswith('#')]),
            "functions": visitor.functions,
            "classes": visitor.classes,
            "complexity": visitor.complexity,
            "imports": visitor.imports,
            "docstrings": visitor.docstrings
        }
        
    def _detect_issues(self, tree: ast.AST, source_code: str) -> List[Dict[str, Any]]:
        """D√©tecte les probl√®mes de code"""
        issues = []
        visitor = IssueVisitor()
        visitor.visit(tree)
        
        # Ajout des issues d√©tect√©es
        issues.extend(visitor.issues)
        
        # V√©rifications suppl√©mentaires
        lines = source_code.split('\n')
        for i, line in enumerate(lines, 1):
            if len(line) > 120:
                issues.append({
                    "type": "line_too_long",
                    "line": i,
                    "message": f"Ligne trop longue ({len(line)} caract√®res)",
                    "severity": "warning"
                })
                
        return issues
        
    def _calculate_quality_score(self) -> float:
        """Calcule un score de qualit√© global"""
        score = 100.0
        
        # P√©nalit√©s bas√©es sur les issues
        critical_issues = len([i for i in self.issues if i.get('severity') == 'critical'])
        warning_issues = len([i for i in self.issues if i.get('severity') == 'warning'])
        
        score -= critical_issues * 15
        score -= warning_issues * 5
        
        # Bonus pour les docstrings
        if self.metrics.get('docstrings', 0) > 0:
            score += 10
            
        return max(0.0, min(100.0, score))
        
    def _generate_recommendations(self) -> List[str]:
        """G√©n√®re des recommandations d'am√©lioration"""
        recommendations = []
        
        if self.metrics.get('complexity', 0) > 10:
            recommendations.append("R√©duire la complexit√© cyclomatique des fonctions")
            
        if self.metrics.get('docstrings', 0) == 0:
            recommendations.append("Ajouter des docstrings aux fonctions et classes")
            
        if len(self.issues) > 5:
            recommendations.append("Corriger les issues d√©tect√©es pour am√©liorer la qualit√©")
            
        return recommendations

class MetricVisitor(ast.NodeVisitor):
    """Visiteur AST pour collecter les m√©triques"""
    
    def __init__(self):
        self.functions = 0
        self.classes = 0
        self.complexity = 0
        self.imports = 0
        self.docstrings = 0
        
    def visit_FunctionDef(self, node):
        self.functions += 1
        # Complexit√© cyclomatique simplifi√©e
        self.complexity += self._count_branches(node)
        if ast.get_docstring(node):
            self.docstrings += 1
        self.generic_visit(node)
        
    def visit_ClassDef(self, node):
        self.classes += 1
        if ast.get_docstring(node):
            self.docstrings += 1
        self.generic_visit(node)
        
    def visit_Import(self, node):
        self.imports += len(node.names)
        
    def visit_ImportFrom(self, node):
        self.imports += len(node.names)
        
    def _count_branches(self, node):
        """Compte les branches pour la complexit√©"""
        branches = 0
        for child in ast.walk(node):
            if isinstance(child, (ast.If, ast.For, ast.While, ast.Try, ast.With)):
                branches += 1
        return branches + 1  # +1 pour la fonction elle-m√™me

class IssueVisitor(ast.NodeVisitor):
    """Visiteur AST pour d√©tecter les issues"""
    
    def __init__(self):
        self.issues = []
        
    def visit_FunctionDef(self, node):
        # Fonction sans docstring
        if not ast.get_docstring(node):
            self.issues.append({
                "type": "missing_docstring",
                "line": node.lineno,
                "message": f"Fonction '{node.name}' sans docstring",
                "severity": "warning"
            })
            
        # Fonction trop longue
        if hasattr(node, 'end_lineno') and node.end_lineno:
            length = node.end_lineno - node.lineno
            if length > 50:
                self.issues.append({
                    "type": "function_too_long",
                    "line": node.lineno,
                    "message": f"Fonction '{node.name}' trop longue ({length} lignes)",
                    "severity": "warning"
                })
                
        self.generic_visit(node)
        
    def visit_ClassDef(self, node):
        # Classe sans docstring
        if not ast.get_docstring(node):
            self.issues.append({
                "type": "missing_docstring",
                "line": node.lineno,
                "message": f"Classe '{node.name}' sans docstring",
                "severity": "warning"
            })
        self.generic_visit(node)

# Fonction factory pour cr√©er l'agent (Pattern Factory)
def create_agent_111_auditeur_qualite(**config) -> 'Agent111AuditeurQualite':
    """Factory function pour cr√©er un Agent111AuditeurQualite conforme Pattern Factory"""
    return Agent111AuditeurQualite(**config)

# Test de l'agent si ex√©cut√© directement
async def main():
    """Test de l'agent Pattern Factory"""
    print("üöÄ D√©marrage test agent_111_auditeur_qualite...")
    agent = create_agent_111_auditeur_qualite()

    try:
        await agent.startup()
        health = await agent.health_check()
        print(f"\U0001F3E5 Health Check: {health}")

        # Test d'une t√¢che
        print("\n\U0001F52C Test de la t√¢che 'execute_mission'...")
        task = Task(type="execute_mission", params={"mission_data": None})
        result = await agent.execute_task(task)
        print(f"   R√©sultat: {'Succ√®s' if result.success else '√âchec'} - {result.data or result.error}")

        # Test de la g√©n√©ration de rapport strat√©gique
        print("\n\U0001F4C4 Test de la t√¢che 'generate_strategic_report'...")
        report_task = Task(type="generate_strategic_report", params={"section": "strat√©gie", "auteur": "test_auto"})
        report_result = await agent.execute_task(report_task)
        print(f"   Rapport g√©n√©r√©: {'Succ√®s' if report_result.success else '√âchec'} - {report_result.data or report_result.error}")

    except Exception as e:
        print(f"‚ùå Erreur durant l'ex√©cution de l'agent: {e}")
    finally:
        await agent.shutdown()
        print("\n‚úÖ Test termin√©.")


if __name__ == "__main__":
    asyncio.run(main())


