#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""

# üîß CONVERTI AUTOMATIQUEMENT SYNC ‚Üí ASYNC
# Date: 2025-06-19 19h35 - Correction architecture Pattern Factory
# Raison: Harmonisation async/sync avec core/agent_factory_architecture.py

üìö AGENT 13 - SP√âCIALISTE DOCUMENTATION - SPRINT 4
Agent Factory Pattern - Guides Production & Documentation API

Mission : Guides production + documentation API + runbooks op√©rateur
R√¥le : Documentation technique compl√®te et standardis√©e

Cr√©√© : 2025-01-28 (Sprint 4)
Auteur : Agent Factory Team
Version : 1.0.0
"""

import json
import sys
from pathlib import Path
from core import logging_manager
import re
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
import os
import sys
import logging

# Configuration paths
AGENT_ROOT = Path(__file__).parent
PROJECT_ROOT = AGENT_ROOT.parent
sys.path.append(str(AGENT_ROOT))

# Configuration de base du logging
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

@dataclass
class DocumentationTemplate:
    """Template documentation standardis√©"""
    title: str
    category: str
    audience: str
    difficulty_level: str
    estimated_read_time: int
    sections: List[Dict[str, Any]]
    prerequisites: List[str]
    related_docs: List[str]
    last_updated: datetime
    author: str

@dataclass
class APIEndpoint:
    """Documentation endpoint API"""
    path: str
    method: str
    description: str
    parameters: Dict[str, Any]
    responses: Dict[str, Any]
    examples: List[Dict[str, Any]]
    authentication: str
    rate_limits: Optional[str]

class Agent13SpecialisteDocumentation:
    """Agent 13 - Sp√©cialiste Documentation pour Agent Factory Implementation"""
    
    CAPABILITIES = ["documentation_generation", "documentation_review"]

    def __init__(self, agent_id="specialiste_documentation_01"):
        self.name = "Agent 13 - Sp√©cialiste Documentation"
        self.agent_id = agent_id
        self.agent_name = "Sp√©cialiste Documentation"
        self.version = "1.0.0"
        self.sprint = "Sprint 4"
        self.mission = "Documentation production compl√®te"
        
        # Logging configuration
        self._setup_logging()
        
        # Documentation paths
        self.docs_root = PROJECT_ROOT / "documentation"
        self.docs_root.mkdir(exist_ok=True)
        self.reports_dir = PROJECT_ROOT / "reports"
        self.reports_dir.mkdir(exist_ok=True)
        
        # Structure documentation
        self.doc_structure = {
            "guides": self.docs_root / "guides",
            "api": self.docs_root / "api", 
            "runbooks": self.docs_root / "runbooks",
            "architecture": self.docs_root / "architecture",
            "deployment": self.docs_root / "deployment",
            "troubleshooting": self.docs_root / "troubleshooting"
        }
        
        for doc_dir in self.doc_structure.values():
            doc_dir.mkdir(exist_ok=True)
            
        # Templates et standards
        self.doc_templates = {}
        self.api_endpoints = {}
        
        self.logger.info(f"üìö {self.agent_name} initialis√© - Sprint 4")
        self.logger.info(f"Rapports g√©n√©r√©s dans : {self.reports_dir}")
        
    def _setup_logging(self):
        """Configuration logging Agent 13"""
        log_dir = PROJECT_ROOT / "logs"
        log_dir.mkdir(exist_ok=True)
        
        log_file = log_dir / f"{self.agent_id}_documentation.log"
        
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.setLevel(logging.INFO)

        # Prevent duplicate handlers
        if not self.logger.handlers:
            # File handler
            fh = logging.FileHandler(log_file)
            fh.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
            self.logger.addHandler(fh)

            # Stream handler
            sh = logging.StreamHandler()
            sh.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
            self.logger.addHandler(sh)
        
    def create_production_guide(self) -> Dict[str, Any]:
        """Guide production op√©rateur complet"""
        try:
            guide_content = """# üîß **GUIDE PRODUCTION - AGENT FACTORY PATTERN**

## **Vue d'Ensemble Production**

### **Architecture Production**
- **Control Plane** : Gouvernance, policies, monitoring centralis√©
- **Data Plane** : Ex√©cution isol√©e agents avec sandbox WASI
- **Performance** : SLA < 50ms cr√©ation template, < 100ms p95
- **S√©curit√©** : RSA 2048 + SHA-256, Vault rotation cl√©s
- **Observabilit√©** : OpenTelemetry + Prometheus + Grafana

### **Agents Production (Sprint 4)**
1. **Agent 08 - Optimiseur Performance** : ThreadPool adaptatif + compression
2. **Agent 09 - Control/Data Plane** : Architecture s√©par√©e s√©curis√©e
3. **Agent 12 - Gestionnaire Backups** : Versioning + rollback
4. **Agent 06 - Monitoring Avanc√©** : Observabilit√© distribu√©e

---

## **‚ö° D√©marrage Rapide Production**

### **1. V√©rification Pr√©requis**
```bash
# V√©rifier versions
python --version  # >= 3.9
docker --version  # >= 20.10
kubectl version   # >= 1.20

# V√©rifier ressources
free -h           # M√©moire >= 8GB
df -h             # Disque >= 50GB
nproc             # CPU >= 4 cores
```

### **2. Initialisation Agent Factory**
```bash
# Clone repository
git clone <repo_url> agent_factory
cd agent_factory/nextgeneration/agent_factory_implementation

# Installation d√©pendances
pip install -r requirements.txt

# Initialisation configuration
python agents/agent_03_specialiste_configuration.py --env=production

# D√©marrage agents Sprint 4
python agents/agent_08_optimiseur_performance.py
python agents/agent_12_gestionnaire_backups.py
```

### **3. Validation Fonctionnement**
```bash
# Health check
curl http://localhost:8000/health

# M√©triques Prometheus
curl http://localhost:8000/metrics

# Cr√©ation test template
curl -X POST http://localhost:8000/factory/create \\
  -H "Content-Type: application/json" \\
  -d '{"id":"test","name":"Test Template"}'
```

---

## **üìä Monitoring Production**

### **M√©triques Cl√©s**
- **Performance** : `agent_factory_response_time_ms` < 50ms
- **Compression** : `agent_factory_compression_ratio` ~ 0.3
- **Cache** : `agent_factory_cache_hit_rate` > 0.8
- **CPU** : `agent_factory_cpu_usage` < 80%
- **M√©moire** : `agent_factory_memory_usage` < 70%

### **Alertes Critiques**
```yaml
# Prometheus alerts
groups:
- name: agent_factory
  rules:
  - alert: PerformanceDegraded
    expr: agent_factory_response_time_ms > 100
    for: 5m
  - alert: CacheHitRateLow  
    expr: agent_factory_cache_hit_rate < 0.5
    for: 10m
```

### **Dashboard Grafana**
- URL : `http://grafana:3000/d/agent-factory`
- Panels : Performance, Compression, Cache, Resources
- Refresh : 30s auto-refresh

---

## **üîß Maintenance Production**

### **Backup Quotidien**
```bash
# Backup automatique (Agent 12)
python agents/agent_12_gestionnaire_backups.py --backup-all

# V√©rification backups
ls -la backups/production/$(date +%Y%m%d)/
```

### **Mise √† Jour S√©curis√©e**
```bash
# 1. Backup pr√©-mise √† jour
python agents/agent_12_gestionnaire_backups.py --create-rollback-plan

# 2. D√©ploiement blue-green
kubectl apply -f deployment/blue-green/

# 3. Validation post-d√©ploiement
./scripts/validate_deployment.sh
```

### **Nettoyage P√©riodique**
```bash
# Nettoyage logs (> 30 jours)
find logs/ -name "*.log" -mtime +30 -delete

# Nettoyage backups anciens
python agents/agent_12_gestionnaire_backups.py --cleanup

# Nettoyage cache templates
python agents/agent_08_optimiseur_performance.py --cache-cleanup
```

---

## **üö® Troubleshooting**

### **Probl√®mes Courants**

#### **Performance D√©grad√©e**
```bash
# Diagnostic performance
python agents/agent_08_optimiseur_performance.py --benchmark

# Optimisation ThreadPool
# Ajuster CPU multiplier dans configuration

# V√©rification compression
# Analyser ratio compression templates
```

#### **√âchecs Signature RSA**
```bash
# V√©rification cl√©s Vault
vault kv get secret/agent-factory/keys

# Rotation manuelle cl√©s
python agents/agent_04_expert_securite_crypto.py --rotate-keys

# Validation signature
python agents/agent_04_expert_securite_crypto.py --validate-all
```

#### **Control/Data Plane Issues**
```bash
# Status planes
python agents/agent_09_specialiste_planes.py --status

# Diagnostic sandbox WASI
python agents/agent_09_specialiste_planes.py --sandbox-test

# V√©rification isolation
ps aux | grep wasi
```

### **Logs Importants**
- **Performance** : `logs/agent_08_performance_optimizer.log`
- **S√©curit√©** : `logs/agent_04_security_crypto.log`
- **Backup** : `logs/agent_12_backup_manager.log`
- **Monitoring** : `logs/agent_06_monitoring.log`

---

## **üìû Contacts Support**

### **√âquipe Agent Factory**
- **Agent 01 (Coordinateur)** : Orchestration g√©n√©rale
- **Agent 16 (Reviewer Senior)** : Validation architecture  
- **Agent 17 (Reviewer Technique)** : Validation impl√©mentation

### **Escalation Proc√©dure**
1. **Niveau 1** : Logs + diagnostics automatiques
2. **Niveau 2** : Rollback plan Agent 12
3. **Niveau 3** : Contact √©quipe d√©veloppement
4. **Niveau 4** : Incident critique - r√©veil √©quipe

---

## **üìã Checklist Maintenance**

### **Quotidien**
- [ ] V√©rifier m√©triques performance
- [ ] Contr√¥ler logs erreurs
- [ ] Valider backups automatiques
- [ ] Monitoring dashboard

### **Hebdomadaire**  
- [ ] Nettoyage logs anciens
- [ ] Test proc√©dures rollback
- [ ] Mise √† jour d√©pendances
- [ ] Audit s√©curit√©

### **Mensuel**
- [ ] Review configuration production
- [ ] Optimisation performance
- [ ] Test disaster recovery
- [ ] Formation √©quipe ops
"""

            # Sauvegarde guide
            guide_file = self.doc_structure["guides"] / "production_operator_guide.md"
            guide_file.write_text(guide_content)
            
            self.logger.info("‚úÖ Guide production op√©rateur cr√©√©")
            
            return {
                "status": "success",
                "guide_file": str(guide_file),
                "sections_count": guide_content.count("##"),
                "word_count": len(guide_content.split())
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur cr√©ation guide production: {e}")
            return {"status": "error", "error": str(e)}
            
    def create_api_documentation(self) -> Dict[str, Any]:
        """Documentation API Agent Factory compl√®te"""
        try:
            # D√©finition endpoints API
            endpoints = [
                APIEndpoint(
                    path="/health",
                    method="GET", 
                    description="Health check syst√®me",
                    parameters={},
                    responses={
                        "200": {"description": "Syst√®me op√©rationnel", "schema": {"status": "healthy"}},
                        "503": {"description": "Syst√®me d√©grad√©", "schema": {"status": "unhealthy", "issues": ["string"]}}
                    },
                    examples=[{"request": "GET /health", "response": {"status": "healthy", "uptime": 3600}}],
                    authentication="None",
                    rate_limits="100/min"
                ),
                APIEndpoint(
                    path="/metrics",
                    method="GET",
                    description="M√©triques Prometheus",
                    parameters={},
                    responses={
                        "200": {"description": "M√©triques format Prometheus", "content_type": "text/plain"}
                    },
                    examples=[{"request": "GET /metrics", "response": "# HELP agent_factory_response_time_ms..."}],
                    authentication="None", 
                    rate_limits="10/min"
                ),
                APIEndpoint(
                    path="/factory/create",
                    method="POST",
                    description="Cr√©ation template optimis√©e",
                    parameters={
                        "body": {
                            "id": {"type": "string", "required": True, "description": "ID unique template"},
                            "name": {"type": "string", "required": True, "description": "Nom template"},
                            "description": {"type": "string", "required": False, "description": "Description"},
                            "type": {"type": "string", "required": False, "default": "standard"}
                        }
                    },
                    responses={
                        "201": {"description": "Template cr√©√© avec succ√®s", "schema": {"template_id": "string", "performance_ms": "number"}},
                        "400": {"description": "Param√®tres invalides", "schema": {"error": "string"}},
                        "500": {"description": "Erreur interne", "schema": {"error": "string"}}
                    },
                    examples=[{
                        "request": {"id": "test_template", "name": "Template Test", "type": "performance"},
                        "response": {"template_id": "test_template", "performance_ms": 42.5, "compressed": True}
                    }],
                    authentication="Bearer token",
                    rate_limits="50/min"
                ),
                APIEndpoint(
                    path="/factory/templates/{id}",
                    method="GET",
                    description="R√©cup√©ration template par ID",
                    parameters={
                        "path": {
                            "id": {"type": "string", "required": True, "description": "ID template"}
                        }
                    },
                    responses={
                        "200": {"description": "Template trouv√©", "schema": {"template": "object"}},
                        "404": {"description": "Template non trouv√©", "schema": {"error": "string"}}
                    },
                    examples=[{
                        "request": "GET /factory/templates/test_template",
                        "response": {"id": "test_template", "name": "Template Test", "created_at": "2025-01-28T10:00:00Z"}
                    }],
                    authentication="Bearer token",
                    rate_limits="100/min"
                ),
                APIEndpoint(
                    path="/backup/create",
                    method="POST",
                    description="Cr√©ation backup via Agent 12",
                    parameters={
                        "body": {
                            "source_path": {"type": "string", "required": True, "description": "Chemin source"},
                            "backup_type": {"type": "string", "required": False, "default": "production", "enum": ["critical", "production", "development"]}
                        }
                    },
                    responses={
                        "201": {"description": "Backup cr√©√©", "schema": {"backup_id": "string", "size_bytes": "number"}},
                        "400": {"description": "Param√®tres invalides", "schema": {"error": "string"}}
                    },
                    examples=[{
                        "request": {"source_path": "/app/templates", "backup_type": "production"},
                        "response": {"backup_id": "backup_1738024800_production", "size_bytes": 1048576}
                    }],
                    authentication="Bearer token (admin)",
                    rate_limits="5/min"
                )
            ]
            
            # G√©n√©ration documentation OpenAPI
            api_doc = {
                "openapi": "3.0.0",
                "info": {
                    "title": "Agent Factory Pattern API",
                    "description": "API pour Agent Factory Pattern - Sprint 4 Production",
                    "version": "1.0.0",
                    "contact": {
                        "name": "Agent Factory Team",
                        "email": "agents@factory.local"
                    }
                },
                "servers": [
                    {"url": "http://localhost:8000", "description": "Development"},
                    {"url": "https://api.agentfactory.production", "description": "Production"}
                ],
                "security": [
                    {"BearerAuth": []}
                ],
                "components": {
                    "securitySchemes": {
                        "BearerAuth": {
                            "type": "http",
                            "scheme": "bearer",
                            "bearerFormat": "JWT"
                        }
                    }
                },
                "paths": {}
            }
            
            # Conversion endpoints vers OpenAPI
            for endpoint in endpoints:
                path_item = {
                    endpoint.method.lower(): {
                        "summary": endpoint.description,
                        "parameters": [],
                        "responses": endpoint.responses
                    }
                }
                
                if endpoint.parameters:
                    for param_type, params in endpoint.parameters.items():
                        for param_name, param_def in params.items():
                            path_item[endpoint.method.lower()]["parameters"].append({
                                "name": param_name,
                                "in": param_type,
                                "required": param_def.get("required", False),
                                "description": param_def.get("description", ""),
                                "schema": {"type": param_def.get("type", "string")}
                            })
                            
                api_doc["paths"][endpoint.path] = path_item
                self.api_endpoints[f"{endpoint.method} {endpoint.path}"] = endpoint
                
            # Sauvegarde documentation API
            api_file = self.doc_structure["api"] / "openapi.json"
            api_file.write_text(json.dumps(api_doc, indent=2))
            
            # Documentation Markdown API
            api_md_content = self._generate_api_markdown(endpoints)
            api_md_file = self.doc_structure["api"] / "API_Documentation.md"
            api_md_file.write_text(api_md_content)
            
            self.logger.info(f"‚úÖ Documentation API cr√©√©e ({len(endpoints)} endpoints)")
            
            return {
                "status": "success",
                "endpoints_count": len(endpoints),
                "openapi_file": str(api_file),
                "markdown_file": str(api_md_file)
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur cr√©ation documentation API: {e}")
            return {"status": "error", "error": str(e)}
            
    def _generate_api_markdown(self, endpoints: List[APIEndpoint]) -> str:
        """G√©n√©ration documentation API Markdown"""
        content = """# üîå **API DOCUMENTATION - AGENT FACTORY PATTERN**

## **Vue d'Ensemble**

L'API Agent Factory Pattern fournit des endpoints pour :
- Cr√©ation et gestion templates optimis√©s
- Monitoring et m√©triques performance  
- Gestion backups et rollbacks
- Health checks et diagnostics

**Base URL :** `https://api.agentfactory.production`  
**Version :** 1.0.0  
**Authentification :** Bearer Token JWT

---

## **üîê Authentification**

```bash
# R√©cup√©ration token
curl -X POST https://auth.agentfactory.production/login \\
  -H "Content-Type: application/json" \\
  -d '{"username": "operator", "password": "secret"}'

# Utilisation token
curl -H "Authorization: Bearer <token>" \\
  https://api.agentfactory.production/factory/create
```

---

## **üìã Endpoints**

"""
        
        for endpoint in endpoints:
            content += f"""### **{endpoint.method} {endpoint.path}**

**Description :** {endpoint.description}  
**Authentification :** {endpoint.authentication}  
**Rate Limits :** {endpoint.rate_limits}

"""
            
            if endpoint.parameters:
                content += "**Param√®tres :**\n\n"
                for param_type, params in endpoint.parameters.items():
                    for param_name, param_def in params.items():
                        required = "**Requis**" if param_def.get("required") else "Optionnel"
                        content += f"- `{param_name}` ({param_def.get('type', 'string')}) - {required} - {param_def.get('description', '')}\n"
                content += "\n"
                
            content += "**R√©ponses :**\n\n"
            for status, response in endpoint.responses.items():
                content += f"- **{status}** : {response.get('description', '')}\n"
            content += "\n"
            
            if endpoint.examples:
                content += "**Exemple :**\n\n"
                example = endpoint.examples[0]
                if isinstance(example.get('request'), dict):
                    content += f"```json\n{json.dumps(example['request'], indent=2)}\n```\n\n"
                else:
                    content += f"```bash\n{example['request']}\n```\n\n"
                    
                content += f"```json\n{json.dumps(example['response'], indent=2)}\n```\n\n"
                
            content += "---\n\n"
            
        return content
        
    def create_runbook_operations(self) -> Dict[str, Any]:
        """Runbook op√©rations production"""
        try:
            runbook_content = """# üìñ **RUNBOOK OP√âRATIONS - AGENT FACTORY PATTERN**

## **üö® Proc√©dures d'Urgence**

### **Incident Performance Critique**
**Sympt√¥mes :** Response time > 500ms, SLA violations
**Impact :** Service d√©grad√© utilisateurs

**Actions Imm√©diates :**
1. **Diagnostic rapide**
   ```bash
   # V√©rifier m√©triques actuelles
   curl -s http://localhost:8000/metrics | grep response_time
   
   # Status agents critiques
   python agents/agent_08_optimiseur_performance.py --status
   python agents/agent_09_specialiste_planes.py --status
   ```

2. **Auto-scaling ThreadPool**
   ```bash
   # Forcer scale-up ThreadPool
   python agents/agent_08_optimiseur_performance.py --scale-up --workers=16
   ```

3. **Cache flush si n√©cessaire**
   ```bash
   # Reset cache templates
   python agents/agent_08_optimiseur_performance.py --cache-flush
   ```

4. **Rollback si √©chec**
   ```bash
   # Rollback derni√®re version stable
   python agents/agent_12_gestionnaire_backups.py --rollback --version=stable
   ```

**Escalation :** Si performance non r√©tablie en 10 minutes

---

### **√âchec S√©curit√© Critique**
**Sympt√¥mes :** Signature RSA failures, Vault inaccessible
**Impact :** Templates non sign√©s, s√©curit√© compromise

**Actions Imm√©diates :**
1. **Isolation s√©curit√©**
   ```bash
   # Activer mode s√©curis√©
   python agents/agent_04_expert_securite_crypto.py --secure-mode
   ```

2. **Diagnostic Vault**
   ```bash
   # Status Vault
   vault status
   
   # Test rotation cl√©s
   python agents/agent_04_expert_securite_crypto.py --test-rotation
   ```

3. **Backup cl√©s critiques**
   ```bash
   # Backup cl√©s urgence
   python agents/agent_12_gestionnaire_backups.py --backup-security
   ```

**Escalation :** Imm√©diate √©quipe s√©curit√©

---

### **Panne Control/Data Plane**
**Sympt√¥mes :** Sandbox WASI offline, isolation compromise
**Impact :** Ex√©cution agents non s√©curis√©e

**Actions Imm√©diates :**
1. **Status planes**
   ```bash
   # Diagnostic complet planes
   python agents/agent_09_specialiste_planes.py --diagnostic-full
   ```

2. **Restart sandbox WASI**
   ```bash
   # Red√©marrage sandbox
   python agents/agent_09_specialiste_planes.py --restart-sandbox
   ```

3. **Validation isolation**
   ```bash
   # Test isolation
   python agents/agent_09_specialiste_planes.py --test-isolation
   ```

---

## **‚öôÔ∏è Proc√©dures Maintenance**

### **Mise √† Jour Production**
**Fen√™tre :** Dimanche 02:00-04:00 UTC  
**Dur√©e estim√©e :** 30 minutes

**Pr√©-requis :**
- [ ] Backup complet valid√©
- [ ] Plan rollback pr√©par√©  
- [ ] √âquipe on-call disponible
- [ ] Tests staging valid√©s

**Proc√©dure :**
1. **Pr√©paration**
   ```bash
   # Backup pr√©-maintenance
   python agents/agent_12_gestionnaire_backups.py --backup-all --type=pre-maintenance
   
   # Plan rollback
   python agents/agent_12_gestionnaire_backups.py --create-rollback-plan --version=current
   ```

2. **Arr√™t contr√¥l√©**
   ```bash
   # Drain traffic
   kubectl patch deployment agent-factory -p '{"spec":{"replicas":0}}'
   
   # Attendre drain complet (2 minutes max)
   kubectl wait --for=condition=available=false deployment/agent-factory --timeout=120s
   ```

3. **D√©ploiement**
   ```bash
   # Blue-green deployment
   kubectl apply -f deployment/blue-green/green/
   
   # Validation green environment
   ./scripts/validate_green_deployment.sh
   ```

4. **Validation**
   ```bash
   # Switch traffic vers green
   kubectl patch service agent-factory -p '{"spec":{"selector":{"version":"green"}}}'
   
   # Validation fonctionnelle
   ./scripts/post_deployment_tests.sh
   ```

5. **Cleanup**
   ```bash
   # Suppression blue si succ√®s
   kubectl delete -f deployment/blue-green/blue/
   ```

**Rollback si √©chec :**
```bash
# Rollback imm√©diat
python agents/agent_12_gestionnaire_backups.py --execute-rollback --plan=latest
```

---

### **Rotation Certificats**
**Fr√©quence :** Mensuelle automatique  
**Validation :** Hebdomadaire

**Proc√©dure automatique :**
```bash
# Rotation automatique Vault
python agents/agent_04_expert_securite_crypto.py --auto-rotate

# Validation rotation
python agents/agent_04_expert_securite_crypto.py --validate-rotation
```

**Proc√©dure manuelle si √©chec :**
```bash
# G√©n√©ration nouveaux certificats
python agents/agent_04_expert_securite_crypto.py --generate-certificates

# D√©ploiement certificats
python agents/agent_04_expert_securite_crypto.py --deploy-certificates

# Test signature
python agents/agent_04_expert_securite_crypto.py --test-signature
```

---

### **Nettoyage Mensuel**
**Fr√©quence :** Premier dimanche du mois  
**Dur√©e :** 1 heure

**Checklist :**
- [ ] Cleanup logs > 30 jours
- [ ] Cleanup backups selon r√©tention
- [ ] Cleanup cache templates
- [ ] Cleanup m√©triques anciennes
- [ ] Validation espace disque

**Commandes :**
```bash
# Logs cleanup
find logs/ -name "*.log" -mtime +30 -delete

# Backups cleanup
python agents/agent_12_gestionnaire_backups.py --cleanup

# Cache cleanup  
python agents/agent_08_optimiseur_performance.py --cache-cleanup

# M√©triques cleanup
curl -X DELETE http://prometheus:9090/api/v1/admin/tsdb/delete_series?match[]={__name__=~"agent_factory.*",job="agent-factory"}
```

---

## **üìä Monitoring & Alertes**

### **M√©triques Critiques**
| M√©trique | Seuil Warning | Seuil Critical | Action |
|----------|---------------|----------------|--------|
| Response Time | > 100ms | > 200ms | Scale ThreadPool |
| Cache Hit Rate | < 70% | < 50% | Cache rebuild |
| CPU Usage | > 80% | > 90% | Scale horizontalement |
| Memory Usage | > 80% | > 90% | Restart + investigation |
| Backup Success | < 95% | < 90% | V√©rification syst√®me backup |

### **Dashboards Grafana**
- **Overview** : `http://grafana:3000/d/agent-factory-overview`
- **Performance** : `http://grafana:3000/d/agent-factory-performance`  
- **Security** : `http://grafana:3000/d/agent-factory-security`
- **Infrastructure** : `http://grafana:3000/d/agent-factory-infra`

### **Alertes Slack**
- Canal : `#agent-factory-alerts`
- Critical : Mention @here
- Warning : Notification normale

---

## **üîç Troubleshooting Guide**

### **FAQ Op√©rations**

**Q: Comment v√©rifier si le syst√®me est healthy ?**
```bash
# Health check complet
curl http://localhost:8000/health

# Status d√©taill√© agents
python agents/agent_01_coordinateur_principal.py --status-all
```

**Q: Performance d√©grad√©e, que faire ?**
1. V√©rifier m√©triques Grafana
2. Analyser logs agents performance
3. Tester benchmark : `python agents/agent_08_optimiseur_performance.py --benchmark`
4. Scale ThreadPool si n√©cessaire

**Q: Comment cr√©er un backup d'urgence ?**
```bash
# Backup complet imm√©diat
python agents/agent_12_gestionnaire_backups.py --emergency-backup

# Validation backup
python agents/agent_12_gestionnaire_backups.py --validate-backup --backup-id=<id>
```

**Q: Comment effectuer un rollback ?**
```bash
# Lister plans rollback disponibles
python agents/agent_12_gestionnaire_backups.py --list-rollback-plans

# Ex√©cuter rollback
python agents/agent_12_gestionnaire_backups.py --execute-rollback --plan=<plan_id>
```

---

## **üìû Contacts & Escalation**

### **Niveaux Support**
1. **L1 - Op√©rateur** : Proc√©dures runbook, monitoring
2. **L2 - Technique** : Diagnostic avanc√©, configuration
3. **L3 - D√©veloppement** : Code, architecture, bugs
4. **L4 - Architecte** : D√©cisions critiques, refactoring

### **Contacts d'Urgence**
- **On-call primary** : +33-XXX-XXX-XXX
- **On-call secondary** : +33-XXX-XXX-XXX  
- **Manager technique** : +33-XXX-XXX-XXX
- **Architecte syst√®me** : +33-XXX-XXX-XXX

### **Canaux Communication**
- **Slack urgent** : `#agent-factory-incidents`
- **Email escalation** : `agent-factory-oncall@company.com`
- **PagerDuty** : Service "Agent Factory Production"
"""

            # Sauvegarde runbook
            runbook_file = self.doc_structure["runbooks"] / "operations_runbook.md"
            runbook_file.write_text(runbook_content)
            
            self.logger.info("‚úÖ Runbook op√©rations cr√©√©")
            
            return {
                "status": "success",
                "runbook_file": str(runbook_file),
                "procedures_count": runbook_content.count("###"),
                "word_count": len(runbook_content.split())
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur cr√©ation runbook: {e}")
            return {"status": "error", "error": str(e)}
            
    def generate_sprint4_report(self) -> Dict[str, Any]:
        """G√©n√©ration rapport Agent 13 Sprint 4"""
        try:
            # Statistiques documentation
            doc_stats = {
                "total_files": 0,
                "total_size_bytes": 0,
                "categories": {}
            }
            
            for category, doc_dir in self.doc_structure.items():
                files = list(doc_dir.glob("*.md")) + list(doc_dir.glob("*.json"))
                file_count = len(files)
                total_size = sum(f.stat().st_size for f in files if f.exists())
                
                doc_stats["categories"][category] = {
                    "files": file_count,
                    "size_bytes": total_size
                }
                doc_stats["total_files"] += file_count
                doc_stats["total_size_bytes"] += total_size
                
            # Rapport Sprint 4
            sprint4_report = {
                "agent_info": {
                    "id": self.agent_id,
                    "name": self.agent_name,
                    "version": self.version,
                    "sprint": self.sprint,
                    "mission": self.mission,
                    "created_at": datetime.now().isoformat()
                },
                "sprint4_objectives": {
                    "production_guide": "‚úÖ Guide production op√©rateur complet",
                    "api_documentation": f"‚úÖ Documentation API ({len(self.api_endpoints)} endpoints)",
                    "runbook_operations": "‚úÖ Runbook op√©rations production",
                    "documentation_structure": f"‚úÖ Structure organis√©e ({len(self.doc_structure)} cat√©gories)",
                    "standards_established": "‚úÖ Standards documentation √©tablis",
                    "integration_agents": "‚úÖ Int√©gration tous agents Sprint 4"
                },
                "documentation_statistics": doc_stats,
                "api_endpoints_count": len(self.api_endpoints),
                "structure_directories": list(self.doc_structure.keys()),
                "integration_status": {
                    "guides_created": True,
                    "api_documented": True,
                    "runbooks_available": True,
                    "standards_defined": True
                },
                "recommendations": [
                    "D√©ployer documentation sur plateforme centralised",
                    "Int√©grer documentation dans CI/CD pipeline",
                    "Configurer g√©n√©ration automatique API docs",
                    "Former √©quipe ops sur runbooks",
                    "Impl√©menter feedback loop documentation"
                ],
                "next_steps_sprint5": [
                    "Documentation d√©ploiement K8s Agent 07",
                    "Runbooks sp√©cifiques production K8s",
                    "Guides troubleshooting clusters",
                    "Documentation monitoring distribu√©"
                ],
                "timestamp": datetime.now().isoformat()
            }
            
            # Sauvegarde rapport
            reports_dir = PROJECT_ROOT / "reports"
            reports_dir.mkdir(exist_ok=True)
            
            report_file = reports_dir / f"{self.agent_id}_rapport_sprint4_{datetime.now().strftime('%Y-%m-%d')}.json"
            report_file.write_text(json.dumps(sprint4_report, indent=2, ensure_ascii=False))
            
            self.logger.info(f"üìä Rapport Sprint 4 g√©n√©r√©: {report_file}")
            
            return sprint4_report
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur g√©n√©ration rapport Sprint 4: {e}")
            return {"error": str(e)}

    def shutdown(self):
        """Ferme les handlers de logging pour lib√©rer les fichiers."""
        self.logger.info(f"Arr√™t de l'agent {self.name} et lib√©ration des logs.")
        handlers = self.logger.handlers[:]
        for handler in handlers:
            handler.close()
            self.logger.removeHandler(handler)

    def run(self, task_prompt: str):
        """
        Point d'entr√©e principal pour l'agent de documentation.
        """
        # Implementation of the run method
        pass

def main():
    """Point d'entr√©e Agent 13"""
    print("üìö D√âMARRAGE AGENT 13 - SP√âCIALISTE DOCUMENTATION - SPRINT 4")
    
    try:
        # Initialisation Agent 13
        agent = Agent13SpecialisteDocumentation()
        
        # Cr√©ation guide production
        print("\nüìñ CR√âATION GUIDE PRODUCTION...")
        guide_result = agent.create_production_guide()
        if guide_result["status"] == "success":
            print(f"‚úÖ Guide cr√©√©: {guide_result['sections_count']} sections")
            print(f"‚úÖ Contenu: {guide_result['word_count']} mots")
        
        # Documentation API
        print("\nüîå G√âN√âRATION DOCUMENTATION API...")
        api_result = agent.create_api_documentation()
        if api_result["status"] == "success":
            print(f"‚úÖ API document√©e: {api_result['endpoints_count']} endpoints")
            print(f"‚úÖ OpenAPI: {api_result['openapi_file']}")
            print(f"‚úÖ Markdown: {api_result['markdown_file']}")
        
        # Runbook op√©rations
        print("\nüìã CR√âATION RUNBOOK OP√âRATIONS...")
        runbook_result = agent.create_runbook_operations()
        if runbook_result["status"] == "success":
            print(f"‚úÖ Runbook cr√©√©: {runbook_result['procedures_count']} proc√©dures")
            print(f"‚úÖ Contenu: {runbook_result['word_count']} mots")
        
        # G√©n√©ration rapport Sprint 4
        print("\nüìä G√âN√âRATION RAPPORT SPRINT 4...")
        sprint4_report = agent.generate_sprint4_report()
        if "error" not in sprint4_report:
            print("‚úÖ Rapport Sprint 4 g√©n√©r√© avec succ√®s")
            print(f"‚úÖ Objectifs Sprint 4: {len([obj for obj in sprint4_report['sprint4_objectives'].values() if '‚úÖ' in obj])}/6 compl√©t√©s")
            print(f"‚úÖ Documentation totale: {sprint4_report['documentation_statistics']['total_files']} fichiers")
            print(f"‚úÖ API endpoints: {sprint4_report['api_endpoints_count']} document√©s")
        
        print("\nüéâ AGENT 13 - SP√âCIALISTE DOCUMENTATION - SPRINT 4 TERMIN√â AVEC SUCC√àS!")
        print("üìö Guide Production | üîå API Docs | üìã Runbooks | üìñ Standards")
        print("üöÄ Pr√™t pour int√©gration Sprint 5 - Documentation K8s Production")
        
        return True
        
    except Exception as e:
        print(f"‚ùå ERREUR AGENT 13: {e}")
        return False

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1) 
