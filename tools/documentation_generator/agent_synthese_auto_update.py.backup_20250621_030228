#!/usr/bin/env python3
"""
ü§ñ AGENT SYNTH√àSE AUTO-UPDATE - NEXTGENERATION
Automatisation mise √† jour SYNTHESE_EXECUTIVE.md et CHANGELOG.md

Fonctionnalit√©s:
- Scan automatique des modifications projet
- Mise √† jour SYNTHESE_EXECUTIVE avec nouvelles missions
- G√©n√©ration CHANGELOG automatique
- Int√©gration Git hooks et workflows

Version: 1.0
Auteur: Syst√®me NextGeneration
"""

import os
import sys
import json
import datetime
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional
import subprocess
import re
from datetime import timedelta

# Configuration logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class AgentSyntheseAutoUpdate:
    """Agent automatisation mise √† jour SYNTHESE_EXECUTIVE et CHANGELOG"""
    
    def __init__(self, dry_run=False):
        self.project_root = Path(__file__).parent.parent.parent
        self.dry_run = dry_run
        
        # Charger la configuration depuis le fichier JSON
        self.config = self._charger_configuration()
        
        # Chemins des fichiers cibles
        self.synthese_path = self.project_root / "docs" / "SYNTHESE_EXECUTIVE.md"
        self.changelog_path = self.project_root / "CHANGELOG.md"
        
        # Chemin des logs
        self.logs_dir = self.project_root / "tools" / "documentation_generator" / "logs"
        self.missions_log_path = self.logs_dir / "missions_detectees.json"
        self.last_run_path = self.logs_dir / "last_auto_update.json"
        self.logs_dir.mkdir(parents=True, exist_ok=True)
        
    def _charger_configuration(self) -> Dict[str, Any]:
        """Charge la configuration depuis le fichier config.json."""
        config_path = self.project_root / "tools" / "documentation_generator" / "config" / "config.json"
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
            logger.info(f"‚úÖ Configuration charg√©e depuis {config_path}")
            return config_data.get("agent_synthese_auto_update", {})
        except FileNotFoundError:
            logger.error(f"‚ùå Fichier de configuration introuvable: {config_path}")
            return {}
        except json.JSONDecodeError:
            logger.error(f"‚ùå Erreur de parsing du fichier de configuration JSON: {config_path}")
            return {}
    
    def detecter_nouvelles_missions(self) -> List[Dict[str, Any]]:
        """D√©tecte automatiquement les nouvelles missions accomplies"""
        logger.info("üîç D√©tection des nouvelles missions accomplies...")
        
        missions = []
        
        # R√©cup√©rer les param√®tres depuis la configuration
        since_days = self.config.get("git_log_since_days", 14)
        keywords = self.config.get("commit_keywords", [])
        
        # Scanner les modifications Git r√©centes
        try:
            # Ne r√©cup√®re que les messages de commit pour √©viter le bruit des noms de fichiers.
            cmd = ["git", "log", f"--since={since_days} days ago", "--pretty=format:%h %s"]
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root, encoding='utf-8', errors='ignore')
            
            if result.returncode == 0:
                commits_recents = result.stdout.strip().split('\\n')
                
                for commit_msg in commits_recents:
                    if any(keyword in commit_msg.lower() for keyword in keywords):
                        missions.append({
                            "source": "git",
                            "type": "commit",
                            "description": commit_msg.split(' ', 1)[1],
                            "date": datetime.now().strftime("%Y-%m-%d"),
                            "reference": commit_msg.split(' ')[0]
                        })
            else:
                logger.warning(f"Git log a √©chou√©: {result.stderr}")
        except FileNotFoundError:
            logger.warning("Git non trouv√©. Le scan des commits est ignor√©.")
        except Exception as e:
            logger.error(f"Erreur lors du scan des commits Git : {e}")
        
        # Scanner dossiers pour nouveaux outils/agents
        missions.extend(self._scanner_dossiers_nouveautes())
        
        # Sauvegarder les missions d√©tect√©es pour analyse
        self._sauvegarder_missions_detectees(missions)
        
        logger.info(f"üîé {len(missions)} mission(s) potentielle(s) d√©tect√©e(s).")
        return missions
    
    def _extraire_nom_mission(self, commit_msg: str) -> str:
        """Extrait le nom de mission du message commit"""
        # Nettoyer le message (enlever hash)
        msg = re.sub(r'^[a-f0-9]{7,}\s+', '', commit_msg).strip()
        
        # Patterns courants
        patterns = [
            r'mission ([^:]+)',
            r'syst√®me ([^:]+)',
            r'([A-Z][^:,]+) (?:accompli|op√©rationnel|valid√©)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, msg, re.IGNORECASE)
            if match:
                return match.group(1).strip().title()
        
        return "Mission Auto-D√©tect√©e"
    
    def _scanner_dossiers_nouveautes(self) -> List[Dict[str, Any]]:
        """Scanner les dossiers pour d√©tecter des nouveaut√©s"""
        missions = []
        
        # Scanner tools/ pour nouveaux outils
        tools_dir = self.project_root / "tools"
        if tools_dir.exists():
            for subdir in tools_dir.iterdir():
                if subdir.is_dir() and not subdir.name.startswith('.'):
                    # V√©rifier si c'est r√©cent
                    creation_time = datetime.datetime.fromtimestamp(subdir.stat().st_mtime)
                    if (datetime.datetime.now() - creation_time).days <= 7:
                        missions.append({
                            'nom': f"Outil {subdir.name.replace('_', ' ').title()}",
                            'date': creation_time.strftime("%Y-%m-%d"),
                            'commit': f"Nouveau: {subdir.name}",
                            'statut': "‚úÖ OUTIL NOUVEAU"
                        })
        
        return missions
    
    def _sauvegarder_missions_detectees(self, missions: List[Dict[str, Any]]):
        """Sauvegarde la liste des missions d√©tect√©es dans un fichier JSON."""
        try:
            with open(self.missions_log_path, 'w', encoding='utf-8') as f:
                json.dump(missions, f, indent=2, ensure_ascii=False)
            logger.info(f"üíæ Missions d√©tect√©es sauvegard√©es dans {self.missions_log_path}")
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde missions d√©tect√©es: {e}")
    
    def mettre_a_jour_synthese_executive(self, missions: List[Dict[str, Any]]) -> bool:
        """Met √† jour le document SYNTHESE_EXECUTIVE.md"""
        if not missions:
            return True
            
        logger.info("üìù Mise √† jour SYNTHESE_EXECUTIVE.md...")
        
        try:
            # Backup
            if self.synthese_path.exists():
                backup_path = self.synthese_path.with_suffix('.md.backup')
                self.synthese_path.rename(backup_path)
            
            # G√©n√©rer nouveau contenu
            contenu = self._generer_synthese_executive(missions)
            self.synthese_path.write_text(contenu, encoding='utf-8')
            
            logger.info("‚úÖ SYNTHESE_EXECUTIVE.md mis √† jour")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur mise √† jour synth√®se: {e}")
            return False
    
    def _generer_synthese_executive(self, missions: List[Dict[str, Any]]) -> str:
        """G√©n√®re le contenu de la synth√®se ex√©cutive"""
        date_actuelle = datetime.datetime.now().strftime("%d %B %Y")
        
        contenu = f'''# üìà SYNTH√àSE EX√âCUTIVE - NEXTGENERATION
*Rapport de missions multiples : Syst√®me Multi-Agents IA Enterprise*
*Date : {date_actuelle}*
*Mise √† jour automatique*

## üéØ R√âSUM√â EX√âCUTIF

**NextGeneration** continue d'√©voluer avec **{len(missions)} nouvelles missions** accomplies r√©cemment.

### üèÜ MISSIONS R√âCENTES

| Mission | Date | Statut | Description |
|---------|------|--------|-------------|
'''
        
        for mission in missions:
            contenu += f"| **{mission['nom']}** | {mission['date']} | {mission['statut']} | {mission['commit']} |\n"
        
        contenu += f'''

### üìä M√âTRIQUES MISES √Ä JOUR

- **{len(missions)} nouvelles missions** d√©tect√©es automatiquement
- **Documentation** mise √† jour en continu
- **Infrastructure** en √©volution constante
- **Automatisation** des processus de reporting

## ü§ñ SYST√àME D'AUTOMATISATION

### üîÑ Mise √† Jour Automatique
- **D√©tection automatique** des nouvelles missions via Git
- **Mise √† jour continue** de la documentation
- **Synchronisation** SYNTHESE_EXECUTIVE et CHANGELOG
- **Int√©gration** dans les workflows existants

### üéØ Prochaines √âvolutions
- **Webhooks Git** pour mise √† jour en temps r√©el
- **Int√©gration** transmission coordinateur
- **Dashboard** de suivi automatique

---
*Synth√®se mise √† jour automatiquement par Agent Synth√®se Auto-Update*
*Derni√®re g√©n√©ration : {date_actuelle}*
'''
        
        return contenu
    
    def mettre_a_jour_changelog(self, missions: List[Dict[str, Any]]) -> bool:
        """Met √† jour le CHANGELOG.md"""
        if not missions:
            return True
            
        logger.info("üìù Mise √† jour CHANGELOG.md...")
        
        try:
            # Lire contenu actuel
            contenu_actuel = ""
            if self.changelog_path.exists():
                contenu_actuel = self.changelog_path.read_text(encoding='utf-8')
            
            # G√©n√©rer nouvelles entr√©es
            nouvelles_entrees = self._generer_entrees_changelog(missions)
            
            # Backup
            if self.changelog_path.exists():
                backup_path = self.changelog_path.with_suffix('.md.backup')
                self.changelog_path.rename(backup_path)
            
            # Ins√©rer au d√©but
            nouveau_contenu = self._inserer_changelog(nouvelles_entrees, contenu_actuel)
            self.changelog_path.write_text(nouveau_contenu, encoding='utf-8')
            
            logger.info("‚úÖ CHANGELOG.md mis √† jour")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur mise √† jour changelog: {e}")
            return False
    
    def _generer_entrees_changelog(self, missions: List[Dict[str, Any]]) -> str:
        """G√©n√®re les nouvelles entr√©es changelog"""
        date_actuelle = datetime.datetime.now().strftime("%Y-%m-%d")
        version = f"[AUTO-{datetime.datetime.now().strftime('%Y.%m.%d')}]"
        
        entrees = f'''## {version} - {date_actuelle} - MISE √Ä JOUR AUTOMATIQUE ü§ñ

### üéâ NOUVELLES MISSIONS D√âTECT√âES
'''
        
        for mission in missions:
            entrees += f"- **{mission['nom']}** - {mission['statut']} ({mission['date']})\n"
        
        entrees += f'''
### üîÑ AUTOMATISATION
- **Agent Synth√®se Auto-Update** d√©ploy√©
- **D√©tection automatique** des nouvelles missions
- **Mise √† jour continue** des documents strat√©giques
- **Int√©gration** dans l'infrastructure NextGeneration

### üìä M√âTRIQUES AUTO-UPDATE
- **Missions d√©tect√©es** : {len(missions)}
- **Documents mis √† jour** : SYNTHESE_EXECUTIVE.md, CHANGELOG.md
- **Mode** : Automatique via Git scanning

'''
        
        return entrees
    
    def _inserer_changelog(self, nouvelles_entrees: str, contenu_actuel: str) -> str:
        """Ins√®re les nouvelles entr√©es dans le changelog"""
        nouveau_contenu = "# üìù CHANGELOG - NEXTGENERATION\n\n"
        nouveau_contenu += nouvelles_entrees
        nouveau_contenu += "\n"
        
        # Ajouter ancien contenu (sans le titre)
        if contenu_actuel:
            lignes = contenu_actuel.split('\n')
            if len(lignes) > 2:
                ancien_contenu = '\n'.join(lignes[2:])
                nouveau_contenu += ancien_contenu
        
        return nouveau_contenu
    
    def executer_mise_a_jour_complete(self) -> Dict[str, Any]:
        """Ex√©cute le processus de mise √† jour de bout en bout."""
        logger.info("üöÄ D√©marrage mise √† jour compl√®te...")
        missions = self.detecter_nouvelles_missions()
        
        if not missions:
            logger.info("‚ÑπÔ∏è Aucune nouvelle mission d√©tect√©e. Aucune mise √† jour n√©cessaire.")
            return {"missions_detectees": 0, "synthese_ok": True, "changelog_ok": True, "erreurs": []}
            
        synthese_ok = self.mettre_a_jour_synthese_executive(missions)
        changelog_ok = self.mettre_a_jour_changelog(missions)
        
        resultats = {
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "missions_detectees": len(missions),
            "synthese_ok": synthese_ok,
            "changelog_ok": changelog_ok,
            "erreurs": []
        }
        
        try:
            # Sauvegarder log
            log_path = self.logs_dir / f"auto_update_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            log_path.write_text(json.dumps(resultats, indent=2), encoding='utf-8')
            
            logger.info("‚úÖ Mise √† jour compl√®te termin√©e")
            
        except Exception as e:
            error_msg = f"Erreur globale: {e}"
            logger.error(error_msg)
            resultats['erreurs'].append(error_msg)
        
        self._sauvegarder_timestamp()
        
        return resultats

    def _sauvegarder_timestamp(self):
        """Sauvegarde le timestamp de la derni√®re ex√©cution."""
        if not self.dry_run:
            timestamp_data = {'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            with open(self.last_run_path, 'w', encoding='utf-8') as f:
                json.dump(timestamp_data, f)
            logger.info(f"Timestamp de l'ex√©cution sauvegard√© dans {self.last_run_path}")

def main():
    """Point d'entr√©e principal"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Agent Synth√®se Auto-Update")
    parser.add_argument("--mode", choices=['detection', 'synthese', 'changelog', 'complet'], 
                       default='complet', help="Mode d'ex√©cution")
    parser.add_argument("--dry-run", action='store_true', help="Mode simulation")
    
    args = parser.parse_args()
    
    agent = AgentSyntheseAutoUpdate(args.dry_run)
    
    print("ü§ñ AGENT SYNTH√àSE AUTO-UPDATE - NEXTGENERATION")
    print("=" * 50)
    
    if args.mode == 'detection':
        missions = agent.detecter_nouvelles_missions()
        print(f"‚úÖ {len(missions)} missions d√©tect√©es")
        
    elif args.mode == 'complet':
        if args.dry_run:
            print("üîç MODE SIMULATION")
            missions = agent.detecter_nouvelles_missions()
            print(f"üìä {len(missions)} missions seraient trait√©es")
        else:
            resultats = agent.executer_mise_a_jour_complete()
            print(f"üìä Missions: {resultats['missions_detectees']}")
            print(f"üìù Synth√®se: {resultats['synthese_ok']}")
            print(f"üìù Changelog: {resultats['changelog_ok']}")

if __name__ == "__main__":
    main() 