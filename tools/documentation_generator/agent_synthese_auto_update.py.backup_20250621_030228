#!/usr/bin/env python3
"""
ğŸ¤– AGENT SYNTHÃˆSE AUTO-UPDATE - NEXTGENERATION
Automatisation mise Ã  jour SYNTHESE_EXECUTIVE.md et CHANGELOG.md

FonctionnalitÃ©s:
- Scan automatique des modifications projet
- Mise Ã  jour SYNTHESE_EXECUTIVE avec nouvelles missions
- GÃ©nÃ©ration CHANGELOG automatique
- IntÃ©gration Git hooks et workflows

Version: 1.0
Auteur: SystÃ¨me NextGeneration
"""

import os
import sys
import json
import datetime
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional
import subprocess
import re
from datetime import timedelta

# Configuration logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class AgentSyntheseAutoUpdate:
    """Agent automatisation mise Ã  jour SYNTHESE_EXECUTIVE et CHANGELOG"""
    
    def __init__(self, dry_run=False):
        self.project_root = Path(__file__).parent.parent.parent
        self.dry_run = dry_run
        
        # Charger la configuration depuis le fichier JSON
        self.config = self._charger_configuration()
        
        # Chemins des fichiers cibles
        self.synthese_path = self.project_root / "docs" / "SYNTHESE_EXECUTIVE.md"
        self.changelog_path = self.project_root / "CHANGELOG.md"
        
        # Chemin des logs
        self.logs_dir = self.project_root / "tools" / "documentation_generator" / "logs"
        self.missions_log_path = self.logs_dir / "missions_detectees.json"
        self.last_run_path = self.logs_dir / "last_auto_update.json"
        self.logs_dir.mkdir(parents=True, exist_ok=True)
        
    def _charger_configuration(self) -> Dict[str, Any]:
        """Charge la configuration depuis le fichier config.json."""
        config_path = self.project_root / "tools" / "documentation_generator" / "config" / "config.json"
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
            logger.info(f"âœ… Configuration chargÃ©e depuis {config_path}")
            return config_data.get("agent_synthese_auto_update", {})
        except FileNotFoundError:
            logger.error(f"âŒ Fichier de configuration introuvable: {config_path}")
            return {}
        except json.JSONDecodeError:
            logger.error(f"âŒ Erreur de parsing du fichier de configuration JSON: {config_path}")
            return {}
    
    def detecter_nouvelles_missions(self) -> List[Dict[str, Any]]:
        """DÃ©tecte automatiquement les nouvelles missions accomplies"""
        logger.info("ğŸ” DÃ©tection des nouvelles missions accomplies...")
        
        missions = []
        
        # RÃ©cupÃ©rer les paramÃ¨tres depuis la configuration
        since_days = self.config.get("git_log_since_days", 14)
        keywords = self.config.get("commit_keywords", [])
        
        # Scanner les modifications Git rÃ©centes
        try:
            # Ne rÃ©cupÃ¨re que les messages de commit pour Ã©viter le bruit des noms de fichiers.
            cmd = ["git", "log", f"--since={since_days} days ago", "--pretty=format:%h %s"]
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root, encoding='utf-8', errors='ignore')
            
            if result.returncode == 0:
                commits_recents = result.stdout.strip().split('\\n')
                
                for commit_msg in commits_recents:
                    if any(keyword in commit_msg.lower() for keyword in keywords):
                        missions.append({
                            "source": "git",
                            "type": "commit",
                            "description": commit_msg.split(' ', 1)[1],
                            "date": datetime.now().strftime("%Y-%m-%d"),
                            "reference": commit_msg.split(' ')[0]
                        })
            else:
                logger.warning(f"Git log a Ã©chouÃ©: {result.stderr}")
        except FileNotFoundError:
            logger.warning("Git non trouvÃ©. Le scan des commits est ignorÃ©.")
        except Exception as e:
            logger.error(f"Erreur lors du scan des commits Git : {e}")
        
        # Scanner dossiers pour nouveaux outils/agents
        missions.extend(self._scanner_dossiers_nouveautes())
        
        # Sauvegarder les missions dÃ©tectÃ©es pour analyse
        self._sauvegarder_missions_detectees(missions)
        
        logger.info(f"ğŸ” {len(missions)} mission(s) potentielle(s) dÃ©tectÃ©e(s).")
        return missions
    
    def _extraire_nom_mission(self, commit_msg: str) -> str:
        """Extrait le nom de mission du message commit"""
        # Nettoyer le message (enlever hash)
        msg = re.sub(r'^[a-f0-9]{7,}\s+', '', commit_msg).strip()
        
        # Patterns courants
        patterns = [
            r'mission ([^:]+)',
            r'systÃ¨me ([^:]+)',
            r'([A-Z][^:,]+) (?:accompli|opÃ©rationnel|validÃ©)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, msg, re.IGNORECASE)
            if match:
                return match.group(1).strip().title()
        
        return "Mission Auto-DÃ©tectÃ©e"
    
    def _scanner_dossiers_nouveautes(self) -> List[Dict[str, Any]]:
        """Scanner les dossiers pour dÃ©tecter des nouveautÃ©s"""
        missions = []
        
        # Scanner tools/ pour nouveaux outils
        tools_dir = self.project_root / "tools"
        if tools_dir.exists():
            for subdir in tools_dir.iterdir():
                if subdir.is_dir() and not subdir.name.startswith('.'):
                    # VÃ©rifier si c'est rÃ©cent
                    creation_time = datetime.datetime.fromtimestamp(subdir.stat().st_mtime)
                    if (datetime.datetime.now() - creation_time).days <= 7:
                        missions.append({
                            'nom': f"Outil {subdir.name.replace('_', ' ').title()}",
                            'date': creation_time.strftime("%Y-%m-%d"),
                            'commit': f"Nouveau: {subdir.name}",
                            'statut': "âœ… OUTIL NOUVEAU"
                        })
        
        return missions
    
    def _sauvegarder_missions_detectees(self, missions: List[Dict[str, Any]]):
        """Sauvegarde la liste des missions dÃ©tectÃ©es dans un fichier JSON."""
        try:
            with open(self.missions_log_path, 'w', encoding='utf-8') as f:
                json.dump(missions, f, indent=2, ensure_ascii=False)
            logger.info(f"ğŸ’¾ Missions dÃ©tectÃ©es sauvegardÃ©es dans {self.missions_log_path}")
        except Exception as e:
            logger.error(f"âŒ Erreur sauvegarde missions dÃ©tectÃ©es: {e}")
    
    def mettre_a_jour_synthese_executive(self, missions: List[Dict[str, Any]]) -> bool:
        """Met Ã  jour le document SYNTHESE_EXECUTIVE.md"""
        if not missions:
            return True
            
        logger.info("ğŸ“ Mise Ã  jour SYNTHESE_EXECUTIVE.md...")
        
        try:
            # Backup
            if self.synthese_path.exists():
                backup_path = self.synthese_path.with_suffix('.md.backup')
                self.synthese_path.rename(backup_path)
            
            # GÃ©nÃ©rer nouveau contenu
            contenu = self._generer_synthese_executive(missions)
            self.synthese_path.write_text(contenu, encoding='utf-8')
            
            logger.info("âœ… SYNTHESE_EXECUTIVE.md mis Ã  jour")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Erreur mise Ã  jour synthÃ¨se: {e}")
            return False
    
    def _generer_synthese_executive(self, missions: List[Dict[str, Any]]) -> str:
        """GÃ©nÃ¨re le contenu de la synthÃ¨se exÃ©cutive"""
        date_actuelle = datetime.datetime.now().strftime("%d %B %Y")
        
        contenu = f'''# ğŸ“ˆ SYNTHÃˆSE EXÃ‰CUTIVE - NEXTGENERATION
*Rapport de missions multiples : SystÃ¨me Multi-Agents IA Enterprise*
*Date : {date_actuelle}*
*Mise Ã  jour automatique*

## ğŸ¯ RÃ‰SUMÃ‰ EXÃ‰CUTIF

**NextGeneration** continue d'Ã©voluer avec **{len(missions)} nouvelles missions** accomplies rÃ©cemment.

### ğŸ† MISSIONS RÃ‰CENTES

| Mission | Date | Statut | Description |
|---------|------|--------|-------------|
'''
        
        for mission in missions:
            contenu += f"| **{mission['nom']}** | {mission['date']} | {mission['statut']} | {mission['commit']} |\n"
        
        contenu += f'''

### ğŸ“Š MÃ‰TRIQUES MISES Ã€ JOUR

- **{len(missions)} nouvelles missions** dÃ©tectÃ©es automatiquement
- **Documentation** mise Ã  jour en continu
- **Infrastructure** en Ã©volution constante
- **Automatisation** des processus de reporting

## ğŸ¤– SYSTÃˆME D'AUTOMATISATION

### ğŸ”„ Mise Ã  Jour Automatique
- **DÃ©tection automatique** des nouvelles missions via Git
- **Mise Ã  jour continue** de la documentation
- **Synchronisation** SYNTHESE_EXECUTIVE et CHANGELOG
- **IntÃ©gration** dans les workflows existants

### ğŸ¯ Prochaines Ã‰volutions
- **Webhooks Git** pour mise Ã  jour en temps rÃ©el
- **IntÃ©gration** transmission coordinateur
- **Dashboard** de suivi automatique

---
*SynthÃ¨se mise Ã  jour automatiquement par Agent SynthÃ¨se Auto-Update*
*DerniÃ¨re gÃ©nÃ©ration : {date_actuelle}*
'''
        
        return contenu
    
    def mettre_a_jour_changelog(self, missions: List[Dict[str, Any]]) -> bool:
        """Met Ã  jour le CHANGELOG.md"""
        if not missions:
            return True
            
        logger.info("ğŸ“ Mise Ã  jour CHANGELOG.md...")
        
        try:
            # Lire contenu actuel
            contenu_actuel = ""
            if self.changelog_path.exists():
                contenu_actuel = self.changelog_path.read_text(encoding='utf-8')
            
            # GÃ©nÃ©rer nouvelles entrÃ©es
            nouvelles_entrees = self._generer_entrees_changelog(missions)
            
            # Backup
            if self.changelog_path.exists():
                backup_path = self.changelog_path.with_suffix('.md.backup')
                self.changelog_path.rename(backup_path)
            
            # InsÃ©rer au dÃ©but
            nouveau_contenu = self._inserer_changelog(nouvelles_entrees, contenu_actuel)
            self.changelog_path.write_text(nouveau_contenu, encoding='utf-8')
            
            logger.info("âœ… CHANGELOG.md mis Ã  jour")
            return True
            
        except Exception as e:
            logger.error(f"âŒ Erreur mise Ã  jour changelog: {e}")
            return False
    
    def _generer_entrees_changelog(self, missions: List[Dict[str, Any]]) -> str:
        """GÃ©nÃ¨re les nouvelles entrÃ©es changelog"""
        date_actuelle = datetime.datetime.now().strftime("%Y-%m-%d")
        version = f"[AUTO-{datetime.datetime.now().strftime('%Y.%m.%d')}]"
        
        entrees = f'''## {version} - {date_actuelle} - MISE Ã€ JOUR AUTOMATIQUE ğŸ¤–

### ğŸ‰ NOUVELLES MISSIONS DÃ‰TECTÃ‰ES
'''
        
        for mission in missions:
            entrees += f"- **{mission['nom']}** - {mission['statut']} ({mission['date']})\n"
        
        entrees += f'''
### ğŸ”„ AUTOMATISATION
- **Agent SynthÃ¨se Auto-Update** dÃ©ployÃ©
- **DÃ©tection automatique** des nouvelles missions
- **Mise Ã  jour continue** des documents stratÃ©giques
- **IntÃ©gration** dans l'infrastructure NextGeneration

### ğŸ“Š MÃ‰TRIQUES AUTO-UPDATE
- **Missions dÃ©tectÃ©es** : {len(missions)}
- **Documents mis Ã  jour** : SYNTHESE_EXECUTIVE.md, CHANGELOG.md
- **Mode** : Automatique via Git scanning

'''
        
        return entrees
    
    def _inserer_changelog(self, nouvelles_entrees: str, contenu_actuel: str) -> str:
        """InsÃ¨re les nouvelles entrÃ©es dans le changelog"""
        nouveau_contenu = "# ğŸ“ CHANGELOG - NEXTGENERATION\n\n"
        nouveau_contenu += nouvelles_entrees
        nouveau_contenu += "\n"
        
        # Ajouter ancien contenu (sans le titre)
        if contenu_actuel:
            lignes = contenu_actuel.split('\n')
            if len(lignes) > 2:
                ancien_contenu = '\n'.join(lignes[2:])
                nouveau_contenu += ancien_contenu
        
        return nouveau_contenu
    
    def executer_mise_a_jour_complete(self) -> Dict[str, Any]:
        """ExÃ©cute le processus de mise Ã  jour de bout en bout."""
        logger.info("ğŸš€ DÃ©marrage mise Ã  jour complÃ¨te...")
        missions = self.detecter_nouvelles_missions()
        
        if not missions:
            logger.info("â„¹ï¸ Aucune nouvelle mission dÃ©tectÃ©e. Aucune mise Ã  jour nÃ©cessaire.")
            return {"missions_detectees": 0, "synthese_ok": True, "changelog_ok": True, "erreurs": []}
            
        synthese_ok = self.mettre_a_jour_synthese_executive(missions)
        changelog_ok = self.mettre_a_jour_changelog(missions)
        
        resultats = {
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "missions_detectees": len(missions),
            "synthese_ok": synthese_ok,
            "changelog_ok": changelog_ok,
            "erreurs": []
        }
        
        try:
            # Sauvegarder log
            log_path = self.logs_dir / f"auto_update_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            log_path.write_text(json.dumps(resultats, indent=2), encoding='utf-8')
            
            logger.info("âœ… Mise Ã  jour complÃ¨te terminÃ©e")
            
        except Exception as e:
            error_msg = f"Erreur globale: {e}"
            logger.error(error_msg)
            resultats['erreurs'].append(error_msg)
        
        self._sauvegarder_timestamp()
        
        return resultats

    def _sauvegarder_timestamp(self):
        """Sauvegarde le timestamp de la derniÃ¨re exÃ©cution."""
        if not self.dry_run:
            timestamp_data = {'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            with open(self.last_run_path, 'w', encoding='utf-8') as f:
                json.dump(timestamp_data, f)
            logger.info(f"Timestamp de l'exÃ©cution sauvegardÃ© dans {self.last_run_path}")

def main():
    """Point d'entrÃ©e principal"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Agent SynthÃ¨se Auto-Update")
    parser.add_argument("--mode", choices=['detection', 'synthese', 'changelog', 'complet'], 
                       default='complet', help="Mode d'exÃ©cution")
    parser.add_argument("--dry-run", action='store_true', help="Mode simulation")
    
    args = parser.parse_args()
    
    agent = AgentSyntheseAutoUpdate(args.dry_run)
    
    print("ğŸ¤– AGENT SYNTHÃˆSE AUTO-UPDATE - NEXTGENERATION")
    print("=" * 50)
    
    if args.mode == 'detection':
        missions = agent.detecter_nouvelles_missions()
        print(f"âœ… {len(missions)} missions dÃ©tectÃ©es")
        
    elif args.mode == 'complet':
        if args.dry_run:
            print("ğŸ” MODE SIMULATION")
            missions = agent.detecter_nouvelles_missions()
            print(f"ğŸ“Š {len(missions)} missions seraient traitÃ©es")
        else:
            resultats = agent.executer_mise_a_jour_complete()
            print(f"ğŸ“Š Missions: {resultats['missions_detectees']}")
            print(f"ğŸ“ SynthÃ¨se: {resultats['synthese_ok']}")
            print(f"ğŸ“ Changelog: {resultats['changelog_ok']}")

if __name__ == "__main__":
    main() 